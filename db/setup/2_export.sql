--------------------------------------------------------
--  Datei erstellt -Sonntag-Mai-09-2021   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for View RECHNUNGEN
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PLSQLTRAINER"."RECHNUNGEN" ("AUFTRAGSNR", "RECHNUNGSDATUM", "KUN_NR", "NACHNAME", "VORNAME", "ORT", "STRASSE", "PLZ", "TNR", "MENGE", "BEZEICHNUNG") AS
  SELECT
Auftraege.Auftragsnr, Auftraege.Rechnungsdatum,
Kunden.Kun_nr, Kunden.Nachname,
Kunden.Vorname, Kunden.Ort,
Kunden.Strasse,Orte.Plz,
Auftragspositionen.TNr,	Auftragspositionen.Menge,
Artikel.Bezeichnung
FROM Kunden, Auftraege, Auftragspositionen, Orte, Artikel
WHERE Kunden.Kun_Nr = Auftraege.Kun_Nr
AND Auftragspositionen.AuftragsNr = Auftraege.AuftragsNr
AND Kunden.Ort = Orte.Ort
AND Kunden.Strasse = Orte.Strasse
AND Artikel.TNR	= Auftragspositionen.TNr
ORDER BY Auftraege.Auftragsnr;
--------------------------------------------------------
--  DDL for View RECHNUNGEN_INF845
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PLSQLTRAINER"."RECHNUNGEN_INF845" ("AUFTRAGSNR", "RECHNUNGSDATUM", "KUN_NR", "NACHNAME", "VORNAME", "ORT", "STRASSE", "PLZ", "TNR", "MENGE", "BEZEICHNUNG") AS
  SELECT "AUFTRAGSNR","RECHNUNGSDATUM","KUN_NR","NACHNAME","VORNAME","ORT","STRASSE","PLZ","TNR","MENGE","BEZEICHNUNG" FROM RECHNUNGEN;
--------------------------------------------------------
--  DDL for Table ABTEILUNGEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."ABTEILUNGEN"
   (	"ABT_NR" NUMBER(38,0),
	"LEITER" NUMBER(38,0),
	"NAME" VARCHAR2(50 BYTE),
	"ORT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANGESTELLTE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."ANGESTELLTE"
   (	"ANG_NR" NUMBER(38,0),
	"ABT_NR" NUMBER(38,0),
	"AUFGABENBESCHREIBUNG" VARCHAR2(50 BYTE),
	"BERUF" VARCHAR2(50 BYTE),
	"NACHNAME" VARCHAR2(50 BYTE),
	"VORNAME" VARCHAR2(50 BYTE),
	"GESCHLECHT" CHAR(1 BYTE),
	"EINTRITTSDATUM" DATE,
	"GEHALT" NUMBER(9,2) DEFAULT 0,
	"ABZUEGE" NUMBER(9,2) DEFAULT 0,
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE),
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ARTIKEL
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."ARTIKEL"
   (	"TNR" NUMBER(38,0),
	"BEZEICHNUNG" VARCHAR2(50 BYTE),
	"ARTIKEL_TYP" VARCHAR2(50 BYTE),
	"VERKAUFSPREIS" NUMBER,
	"JAHRESUMSATZ" NUMBER,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table AUFTRAEGE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."AUFTRAEGE"
   (	"AUFTRAGSNR" NUMBER(38,0),
	"AUFTRAGS_TYP" VARCHAR2(50 BYTE),
	"KUN_NR" NUMBER(38,0),
	"ANG_NR" NUMBER(38,0),
	"BEREITS_GEZAHLT" NUMBER,
	"BESTELLDATUM" DATE,
	"LIEFERDATUM" DATE,
	"RECHNUNGSDATUM" DATE,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN"
   (	"TNR" NUMBER(38,0),
	"AUFTRAGSNR" NUMBER(38,0),
	"MENGE" NUMBER
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FIRINGSTATEMENTS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS"
   (	"QUESTIONID" NUMBER,
	"EXECORDER" NUMBER,
	"FIRINGCODE" VARCHAR2(500 CHAR)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FUNC_CALLS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."FUNC_CALLS"
   (	"QUESTIONID" NUMBER,
	"EXECORDER" NUMBER,
	"CALL" VARCHAR2(500 CHAR)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FUNC_QUESTIONS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."FUNC_QUESTIONS"
   (	"QUESTIONID" NUMBER,
	"TEXT" VARCHAR2(1000 CHAR),
	"TESTTABLE" VARCHAR2(20 CHAR),
	"FUNCTIONNAME" VARCHAR2(20 CHAR),
	"SAMPLEFUNCTION" VARCHAR2(1000 CHAR),
	"QUESTIONTYP" VARCHAR2(64 BYTE),
	"NEEDEDTABLE" VARCHAR2(128 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table GEHALTSPROTOKOLL
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."GEHALTSPROTOKOLL"
   (	"ANG_NR" NUMBER(38,0),
	"ALT_GEHALT" NUMBER(9,2) DEFAULT 0,
	"NEU_GEHALT" NUMBER(9,2) DEFAULT 0,
	"DATUM" DATE
   ) SEGMENT CREATION DEFERRED
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table GEH_KLASSEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."GEH_KLASSEN"
   (	"GEH_KLASSE" NUMBER(38,0),
	"MAX_GEHALT" NUMBER,
	"MIN_GEHALT" NUMBER
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table KUNDEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."KUNDEN"
   (	"KUN_NR" NUMBER(38,0),
	"NACHNAME" VARCHAR2(50 BYTE),
	"VORNAME" VARCHAR2(50 BYTE),
	"GESCHLECHT" VARCHAR2(1 BYTE),
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE),
	"TELEFONNR" VARCHAR2(50 BYTE),
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table KUNDEN_LEON
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."KUNDEN_LEON"
   (	"KUN_NR" NUMBER(38,0),
	"NACHNAME" VARCHAR2(50 BYTE),
	"VORNAME" VARCHAR2(50 BYTE),
	"GESCHLECHT" VARCHAR2(1 BYTE),
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE),
	"TELEFONNR" VARCHAR2(50 BYTE),
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LAGER
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."LAGER"
   (	"LANR" NUMBER(38,0),
	"BEZEICHNUNG" VARCHAR2(50 BYTE),
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LAGERBESTAND
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."LAGERBESTAND"
   (	"LANR" NUMBER(38,0),
	"TNR" NUMBER(38,0),
	"BESTAND" NUMBER,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERANTEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."LIEFERANTEN"
   (	"LIEF_NR" NUMBER(38,0),
	"NAME" VARCHAR2(50 BYTE),
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE),
	"TELEFONNR" VARCHAR2(50 BYTE),
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERPROGRAMME
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."LIEFERPROGRAMME"
   (	"LIEF_NR" NUMBER(38,0),
	"TNR" NUMBER(38,0),
	"BESTELLNR" VARCHAR2(20 BYTE),
	"EINKAUFSPREIS" NUMBER,
	"GESAMTMENGE" NUMBER,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERUNGEN
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."LIEFERUNGEN"
   (	"LIEFER_NR" NUMBER(38,0),
	"LIEF_NR" NUMBER(38,0),
	"TNR" NUMBER(38,0),
	"LIEF_DATUM" DATE,
	"MENGE" NUMBER DEFAULT 1,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ORA_ERROR
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."ORA_ERROR"
   (	"ORA_ERROR_ID" NUMBER(10,0),
	"ERROR_HINT_ID" NUMBER(10,0),
	"COUNTER" NUMBER(10,0),
	"ERROR_TEXT" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ORTE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."ORTE"
   (	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE),
	"PLZ" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table OUTPUT_TABLE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."OUTPUT_TABLE"
   (	"COLUMN_VALUE" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION DEFERRED
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table POSITIONSARCHIV
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."POSITIONSARCHIV"
   (	"TNR" NUMBER(38,0),
	"AUFTRAGSNR" NUMBER(38,0),
	"MENGE" NUMBER
   ) SEGMENT CREATION DEFERRED
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table PROC_CALLS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."PROC_CALLS"
   (	"QUESTIONID" NUMBER,
	"EXECORDER" NUMBER,
	"CALL" VARCHAR2(500 CHAR)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table PROC_QUESTIONS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."PROC_QUESTIONS"
   (	"QUESTIONID" NUMBER,
	"TEXT" VARCHAR2(500 CHAR),
	"TESTTABLE" VARCHAR2(20 CHAR),
	"PROCNAME" VARCHAR2(20 CHAR),
	"SAMPLEPROC" VARCHAR2(1000 CHAR),
	"QUESTIONTYP" VARCHAR2(64 BYTE),
	"NEEDEDTABLE" VARCHAR2(128 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table QUESTIONS
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."QUESTIONS"
   (	"QUESTIONID" NUMBER,
	"TEXT" VARCHAR2(500 CHAR),
	"TESTTABLE" VARCHAR2(20 CHAR),
	"TRIGGERNAME" VARCHAR2(20 CHAR),
	"SAMPLETRIGGER" VARCHAR2(1000 CHAR),
	"QUESTIONTYP" VARCHAR2(64 BYTE),
	"NEEDEDTABLE" VARCHAR2(128 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table STRUKTUR
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."STRUKTUR"
   (	"OTEIL" NUMBER(38,0),
	"UTEIL" NUMBER(38,0),
	"POSITION" NUMBER(38,0),
	"MENGE" NUMBER,
	"AUSSCHUSS" NUMBER,
	"ARBEITSGANG" NUMBER(38,0),
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEILE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."TEILE"
   (	"TNR" NUMBER(38,0),
	"ME" VARCHAR2(10 BYTE),
	"BEZEICHNUNG" VARCHAR2(50 BYTE),
	"TYP" VARCHAR2(50 BYTE),
	"HERSTELLKOSTEN" NUMBER,
	"EINKAUFSPREIS" NUMBER,
	"MINDESTBESTAND" NUMBER,
	"BESTAND" NUMBER,
	"LIEFERZEIT" NUMBER,
	"HERSTELLDAUER" NUMBER,
	"GEWICHT" NUMBER,
	"RESERVIERT" NUMBER,
	"VERFUEGBAR" NUMBER,
	"ZEITSTEMPEL" DATE
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEILE_WERKE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."TEILE_WERKE"
   (	"TNR" NUMBER(38,0),
	"WNR" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table WERKE
--------------------------------------------------------

  CREATE TABLE "PLSQLTRAINER"."WERKE"
   (	"WNR" NUMBER(38,0),
	"BEZEICHNUNG" VARCHAR2(50 BYTE),
	"ORT" VARCHAR2(50 BYTE),
	"STRASSE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Sequence LIEFER_NR
--------------------------------------------------------

   CREATE SEQUENCE  "PLSQLTRAINER"."LIEFER_NR"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 61 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
REM INSERTING into PLSQLTRAINER.ABTEILUNGEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('1','1','GESCH�FTSF�HRUNG','K�ln');
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('2','2','PRODUKTION','Lindlar');
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('3','3','VERTRIEB','Dortmund');
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('4','4','EINKAUF','Lindlar');
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('5','5','ARBEITSVORBEREITUNG','Lindlar');
Insert into PLSQLTRAINER.ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('6','6','DATENVERARBEITUNG','K�ln');
REM INSERTING into PLSQLTRAINER.ANGESTELLTE
SET DEFINE OFF;
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('1','1','Manchmal sind die Frauen Chef','Betriebswirt','M�ller','Josefine','w',to_date('01.02.91','DD.MM.RR'),'10000','3400','K�ln','Memelerstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('2','2','Fehlt noch','Mathematiker','Fama','Hans','m',to_date('07.05.91','DD.MM.RR'),'9000','2300','Gummersbach','Inselweg',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('3','3','Fehlt noch','Betriebswirt','Heck','Iris','w',to_date('06.07.88','DD.MM.RR'),'7500','3000','Gummersbach','Kaiserstr',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('4','4','Fehlt noch','Kaufmann','Schmidt','Otto','m',to_date('01.07.95','DD.MM.RR'),'6500','2000','Leverkusen','Netzestr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('5','5','Fehlt noch','Informatiker','Weber','Anna','w',to_date('01.06.95','DD.MM.RR'),'6600','2000','Leverkusen','Quarzstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('6','6','Fehlt noch','Informatiker','Frisch','Paul','m',to_date('01.06.99','DD.MM.RR'),'5000','2000','Bergisch Gladbach','Grubenfeld',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('7','6','Fehlt noch','Informatiker','Frisch','Paula','w',to_date('01.03.93','DD.MM.RR'),'5000','2100','Bergisch Gladbach','Grubenfeld',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('8','2','Fehlt noch','Informatiker','Weber','Anna','w',to_date('01.06.95','DD.MM.RR'),'3700','1500','Bergisch Gladbach','Burgstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('9','2','Fehlt noch','Ingenieur','Falser','Jonas','m',to_date('01.06.95','DD.MM.RR'),'3600','1500','Bergisch Gladbach','Burgstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('10','2','Fehlt noch','Schreibkraft','Wanne','Erna','w',to_date('01.06.95','DD.MM.RR'),'4000','10','Bergisch Gladbach','Erntestr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('11','2','Fehlt noch','Elektriker','Brunn','Ilse','w',to_date('01.01.95','DD.MM.RR'),'3600','1500','Bergisch Gladbach','Fichtenweg',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('12','3','Fehlt noch','Ingenieur','Brater','Willi','m',to_date('01.01.97','DD.MM.RR'),'4600','1500','Dortmund','Bedastr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('13','3','Fehlt noch','Ingenieur','Baer','Susanne','w',to_date('01.01.92','DD.MM.RR'),'4800','1500','Dortmund','Prellerstr.',null);
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('14','3','Fehlt noch','Schreibkraft','Bille','Max','m',to_date('01.01.93','DD.MM.RR'),'610','30','Dortmund','Plutostr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('15','4','Fehlt noch','Kaufmann','Wahn','Thorsten','m',to_date('01.01.94','DD.MM.RR'),'3610','1030','Gladbeck','Weserstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('16','4','Fehlt noch','Kaufmann','Wuton','Petra','w',to_date('01.01.94','DD.MM.RR'),'4610','1230','Gladbeck','Triebstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('17','5','Fehlt noch','Kaufmann','Glatt','Lucas','m',to_date('01.01.94','DD.MM.RR'),'5200','2230','Gladbeck','Alfredstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('18','5','Fehlt noch','Kaufmann','Gotte','Barbara','w',to_date('01.01.94','DD.MM.RR'),'5500','3230','Gladbeck','Saarlandstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('19','5','Fehlt noch','Kaufmann','Kall','Holger','m',to_date('01.01.94','DD.MM.RR'),'4500','3230','Gladbeck','Talstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('20','6','Fehlt noch','Informatiker','K�se','Franz','m',to_date('01.01.97','DD.MM.RR'),'4500','3230','Gladbeck','Talstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('21','6','Fehlt noch','Informatiker','Kussmann','Anna','w',to_date('01.01.97','DD.MM.RR'),'4500','3230','Gladbeck','Unterhof',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('22','6','Fehlt noch','Informatiker','Bold','Leo','m',to_date('01.01.97','DD.MM.RR'),'3500','3230','Gladbeck','Thomastr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('23','6','Fehlt noch','Informatiker','Butz','Max','m',to_date('01.01.98','DD.MM.RR'),'3500','3230','Gladbeck','Unterhof',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('24','2','Fehlt noch','Montieur','Schmidt','Hugo','m',to_date('01.01.98','DD.MM.RR'),'3500','3230','Gladbeck','Roonstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('25','2','Fehlt noch','Betriebswirt','Barthels','Isabel','w',to_date('01.01.95','DD.MM.RR'),'3500','3230','Gladbeck','Schildberg',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('26','2','Fehlt noch','Kaufmann','Schneider','Ernst','m',to_date('01.06.95','DD.MM.RR'),'4000','2000','Bergisch Gladbach','Falkenstr.',to_date('13.03.02','DD.MM.RR'));
Insert into PLSQLTRAINER.ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('27','3','Fehlt noch','Schreibkraft','Budar','Hermann','m',to_date('01.01.96','DD.MM.RR'),'2800','1500','Dortmund','Planckstr.',null);
REM INSERTING into PLSQLTRAINER.ARTIKEL
SET DEFINE OFF;
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('1','Rocky Mountain Element Race Typ 1','Mountainbike','3500','200',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('31','Herrenrad GT-LTS 18','Rennrad','3500','400',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('54','Klapprad Prompton P3','Klapprad','1600','180',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('55','CANNONDALE FSL','Mountainbike','3700','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('56','HERCULES NEPA','Trekkingrad','1700','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('57','Steppenwolf TAO','Mountainbike','1900','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('58','SWITCHBACK AGENT','Jugendrad','899','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('59','STEVENS R.P.R.2 RX100 8FACH','Rennmaschine','1800','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('60','Scott ATACAMA TOUR','Crossrad','2399','80',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('61','ROTWILD RCC-03','Mountainbike','3499','80',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.AUFTRAEGE
SET DEFINE OFF;
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('1','Auftrag','1','3','0',to_date('27.07.18','DD.MM.RR'),to_date('26.08.18','DD.MM.RR'),to_date('25.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('2','Auftrag','2','12','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('3','Angebot','5','12','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('4','Auftrag','2','13','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('5','Angebot','3','27','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('6','Auftrag','2','3','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.AUFTRAGSPOSITIONEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('1','1','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','1','2');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','2','2');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('60','2','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('57','2','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','3','10');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('55','3','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('58','4','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('58','5','18');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('56','5','1');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('57','5','12');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('1','6','120');
Insert into PLSQLTRAINER.AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','6','130');
REM INSERTING into PLSQLTRAINER.FIRINGSTATEMENTS
SET DEFINE OFF;
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('1','1','INSERT INTO Angestellte VALUES (28, 3, ''Fehlt noch'', ''Schreibkraft'',
''Budar'', ''Hermann'', ''m'',  TO_Date( ''01/01/1996 12:00:00 AM'', ''MM/DD/YYYY HH:MI:SS AM'')
, 2800, 1500, ''Dortmund'', ''Planckstr.'', NULL)');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('2','1','update Abteilungen set Leiter=10 where Name=''Einkauf''');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('3','1','update Lagerbestand set bestand = 1000 where tnr=1 and lanr=2');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('4','1','update Auftraege set bereits_gezahlt=10500 where auftragsnr=1');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('5','1','update angestellte set gehalt=4100 where ang_nr=26');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('6','1','delete from Auftragspositionen where AuftragsNR=5');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('7','1','update Angestellte set Gehalt=5500 where Ang_Nr=7');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('8','2','update Angestellte set gehalt=9000 where ang_nr=1');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('9','2','update angestellte set ang_nr=30 where ang_nr=2');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('10','2','update Geh_klassen set max_gehalt=4500 where geh_klasse=4');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('8','1','update Angestellte set gehalt=8000 where ang_nr=3');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('2','2','update Abteilungen set Leiter=12 where Name=''Produktion''');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('4','2','update Auftraege set bereits_gezahlt=10000 where auftragsnr=2');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('5','2','update angestellte set gehalt=6000 where ang_nr=6');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('7','2','update Angestellte set Nachname=''Schmitz'' where Ang_Nr=8');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('9','1','update Angestellte set Nachname=''Schmitz'' where Ang_Nr=8');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('10','1','update Geh_klassen set max_gehalt=1500 where geh_klasse=5');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('11','1','UPDATE Rechnungen SET MENGE = 2 WHERE TNR = 1 AND AUFTRAGSNR = 1');
Insert into PLSQLTRAINER.FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('12','1','INSERT INTO Rechnungen VALUES (1,TO_Date( ''02/01/0091 12:00:00 AM'', ''MM/DD/YYYY HH:MI:SS AM''),1,''Sonnenschein'',''Susi'',''Koeln'',''Testweg'',51709,60,22,''Test'')');
REM INSERTING into PLSQLTRAINER.FUNC_CALLS
SET DEFINE OFF;
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','1','tage_im_jahr(1984)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','2','tage_im_jahr(2000)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','3','tage_im_jahr(2100)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','1','anrede_bestimmen(''M'',''Schmitz'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','2','anrede_bestimmen(''w'',''Meier'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','3','anrede_bestimmen('''','''')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','4','anrede_bestimmen(''M'','''')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','1','gehaltsklasse(7)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','2','gehaltsklasse(14)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','3','gehaltsklasse(2)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','1','stueckliste(60)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','2','stueckliste(62)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','3','stueckliste(2)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','1','zeichen_pruefen(''Daten:banken'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','2','zeichen_pruefen(''Datenbank:en'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','3','zeichen_pruefen(''D:aten:bank:en'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','4','zeichen_pruefen(''Datenbanken'')');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','1','eur_to_usd(15)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','2','eur_to_usd(99)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','1','taschenrechner(1,''+'',1)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','2','taschenrechner(4,''*'',8)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','3','taschenrechner(984,''/'',84)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','4','taschenrechner(99,''-'',101)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','1','schaltjahr_check(1984)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','2','schaltjahr_check(2000)');
Insert into PLSQLTRAINER.FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','3','schaltjahr_check(2100)');
REM INSERTING into PLSQLTRAINER.FUNC_QUESTIONS
SET DEFINE OFF;
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('3','Schreiben Sie eine PL/SQL-Funktion mit dem Namen "tage_im_jahr", die zu einem gegebenen Jahr die Zahl der Tage zur�ckliefert. Schaltjahre mit 366 Tagen sind solche, die durch 400 teilbar sind und au�erdem solche, die durch 4, aber nicht durch 100 teilbar sind. Alle anderen Jahre haben 365 Tage.

Hinweis: Benutzen Sie die Modulo-Funktion MOD(n,m), die den Rest beim Teilen von n durch m liefert.','output_table','tage_im_jahr','CREATE OR REPLACE Function tage_im_jahr (Jahr INTEGER)
RETURN INTEGER AS
test_400 INTEGER;
test_100 INTEGER;
test_4   INTEGER;
Ergebnis INTEGER;
BEGIN
  test_400 :=  MOD (Jahr, 400);
  test_100 :=  MOD (Jahr, 100);
  test_4   :=  MOD (Jahr, 4);
  IF test_400 = 0 OR (test_100 > 0 AND test_4 = 0)
  THEN
  Ergebnis := 366;
  ELSE
  Ergebnis := 365;
  END IF;
 RETURN Ergebnis;
END;','function','output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('5','Schreiben Sie eine Funktion mit dem Namen "anrede_bestimmen", der als �bergabeparameter ein Geschlecht und ein Nachname mitgegeben wird. Das Ergebnis soll wie folgt aussehen: "Sehr geehrte Frau Meier", bzw. "Sehr geehrter Herr M�ller". Beim Geschlecht sind die zul�ssigen Werte "leer/NULL", "w" und "m", unabh�ngig von der Gro�/Kleinschreibung, beim Nachnamen kann auch ein Nullwert �bergeben werden. Wird kein Geschlecht oder kein Nachname �bergeben (NULL), oder wird als Geschlecht ein ung�ltiger Wert �bergeben, dann wird nur die Anrede "Sehr geehrte Damen und Herren" zur�ckgegeben, unabh�ngig von den Werten des anderen Parameters.','output_table','anrede_bestimmen','CREATE OR REPLACE FUNCTION anrede_bestimmen (
   p_geschlecht   IN VARCHAR2 DEFAULT NULL,
   p_nachname     IN VARCHAR2 DEFAULT NULL)
   RETURN VARCHAR2
IS
   v_anrede   VARCHAR2 (30) := ''Sehr geehrte'';
BEGIN
   IF p_geschlecht NOT IN (''W'', ''w'', ''M'', ''m'') OR p_nachname IS NULL
   THEN
      RETURN ''Sehr geehrte Damen und Herren'';
   END IF;
   IF p_geschlecht IN (''W'', ''w'')
   THEN
      v_anrede := v_anrede || '' Frau '';
   ELSIF p_geschlecht IN (''M'', ''m'')
   THEN
      v_anrede := v_anrede || ''r Herr '';
   END IF;
   RETURN v_anrede || p_nachname;
END;','function','output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('6','Schreiben Sie eine PL/SQL-Funktion "gehaltsklasse", die zu einem Angestellten die Gehaltsklasse ermittelt. �bergeben werden soll die Ang-Nr, ermittelt werden soll die Gehaltsklasse, d.h. die Geh_Klasse, so dass das Gehalt gr��er als das Min_Gehalt und kleiner oder gleich dem Max_Gehalt ist.','output_table','gehaltsklasse','CREATE OR REPLACE FUNCTION gehaltsklasse (
   p_ang_nr   IN NUMBER DEFAULT NULL)
   RETURN NUMBER
IS
   v_klasse   NUMBER DEFAULT 0;
BEGIN
   SELECT GEH_KLASSEN.GEH_KLASSE
     INTO v_klasse
     FROM angestellte, geh_klassen
    WHERE     angestellte.gehalt > GEH_KLASSEN.MIN_GEHALT
          AND angestellte.gehalt <= GEH_KLASSEN.MAX_GEHALT
          AND ANGESTELLTE.ANG_NR = p_ang_nr;
   RETURN v_klasse;
END;','function','angestellte,geh_klassen,output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('7','Schreiben Sie eine PL/SQL-Funktion "stueckliste", die zu einer Teile_Nr die St�cklistentiefe bestimmt, d.h. die L�nge des maximalen Wegs in der St�ckliste, die zu einem Blatt f�hrt. Die St�cklisten werden in der Struktur-Tabelle verwaltet, d.h. z.B. die Beziehung des Teils mit der Nummer 60 zum Teil 2 wird in der Struktur-Tabelle in der Zeile mit dem OTEIL = 60 und dem UTEIL = 2 gespeichert. Die Tiefe ist in diesem Beispiel 3. Verwenden Sie dazu das CONNECT-BY-Statement von Oracle!','output_table','stueckliste','CREATE OR REPLACE FUNCTION stueckliste (
   p_oteil   IN NUMBER DEFAULT NULL)
   RETURN NUMBER
IS
   v_tiefe   NUMBER DEFAULT 0;
BEGIN
       SELECT MAX (LEVEL) into v_tiefe
         FROM Struktur
   START WITH OTeil = p_oteil
   CONNECT BY PRIOR UTeil = OTeil;

   RETURN v_tiefe;
END;','function','struktur,output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('8','Schreiben Sie eine PL/SQL-Funktion "zeichen_pruefen", die f�r einen �bergebenen Text pr�ft, an welcher Stelle im Text ein Doppelpunkt enthalten ist! Der R�ckgabewert soll vom Typ INTEGER sein und die Position enthalten, an der das gesuchte Zeichen, n�mlich der Doppelpunkt, zum ersten Mal auftritt! Falls kein Doppelpunkt auftritt, soll der Wert 0 zur�ckgegeben werden.
Sie k�nnen die Oracle-Funktion INSTR nutzen
    � instr( string1, string2 [, start_position [,  nth_appearance ] ] )
        ? string1:   zu durchsuchender Text.,
        ? string2:	  Substring, der in string 1 gesucht wird.
        ? Start_position: ist optional
        ? nth_appearance  Wie oft der string 1 in string 2 auftritt, ist optional
Instr gibt 0 zur�ck, wenn der string2 nicht gefunden wird.','output_table','zeichen_pruefen','CREATE OR REPLACE FUNCTION zeichen_pruefen (text VARCHAR2)
   RETURN INTEGER
IS
zahl  integer :=  0;
BEGIN
   zahl :=  INSTR (text, '':'', 1,  1);
   RETURN zahl;
END;','function','output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('4','Schreiben Sie eine Taschenrechner-Funktion "taschenrechner", die die vier Grundrechenarten kann: Addition �+�, Subtraktion �-�, Division �/�, Multiplikation �*�!
Der Funktion werden drei Parameter �bergeben, den ersten Operanden, das Symbol der Rechenoperation und den zweiten Operanden. Das berechnete Ergebnis ist der R�ckgabewert.','output_table','taschenrechner','CREATE OR REPLACE FUNCTION taschenrechner (o1 IN NUMBER, operator   IN VARCHAR2, o2  IN NUMBER)
   RETURN NUMBER
IS
BEGIN
  IF   operator  = ''+'' THEN RETURN o1 + o2;
  ELSIF operator = ''-'' THEN RETURN o1 - o2;
  ELSIF operator = ''*'' THEN RETURN o1 * o2;
  ELSIF operator = ''/'' THEN RETURN o1 / o2;
  END IF;
END;','function','output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('1','Schreiben Sie eine PL/SQL-Funktion mit dem Namen "schaltjahr_check", die, wenn ein �bergebenes Jahr ein Schaltjahr ist, den booleschen Wert TRUE zur�ckgibt und wenn nicht, den Wert FALSE. Schaltjahre mit 366 Tagen sind solche, die durch 400 teilbar sind und au�erdem solche, die durch 4, aber nicht durch 100 teilbar sind. Alle anderen Jahre haben 365 Tage.

Hinweis: Benutzen Sie die Modulo-Funktion MOD(n,m), die den Rest beim Teilen von n durch m liefert.','output_table','schaltjahr_check','CREATE OR REPLACE FUNCTION schaltjahr_check (p_jahr INTEGER)
RETURN  VARCHAR2
AS
BEGIN
    IF      MOD(p_jahr, 400) = 0
       OR  (MOD(p_jahr, 100) <> 0 AND MOD(p_jahr, 4) = 0)
    THEN
       DBMS_OUTPUT.PUT_LINE(p_jahr||'' ist ein Schaltjahr!'');
       RETURN ''TRUE'';
    ELSE
       DBMS_OUTPUT.PUT_LINE(p_jahr||'' ist kein Schaltjahr!'');
       RETURN ''FALSE'';
    END IF;
END;','function','output_table');
Insert into PLSQLTRAINER.FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('2','Es soll eine Funktion "eur_to_usd" erstellt werden, der ein Wert in � �bergeben wird und ihn umgerechnet in Dollar zur�ckgibt. Der Wechselkurs f�r diese Aufgabe ist 1.13 (1� = 1,13$)','output_table','eur_to_usd','CREATE OR REPLACE FUNCTION eur_to_usd (euro NUMBER)
  RETURN NUMBER IS
  buffer NUMBER;
  BEGIN
    buffer := (euro * 1.13);
    RETURN buffer;
END;','function','output_table');
REM INSERTING into PLSQLTRAINER.GEHALTSPROTOKOLL
SET DEFINE OFF;
REM INSERTING into PLSQLTRAINER.GEH_KLASSEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('1','100000','8000');
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('2','7999','6000');
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('3','5999','4000');
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('4','3999','2000');
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('5','1999','620');
Insert into PLSQLTRAINER.GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('6','620','0');
REM INSERTING into PLSQLTRAINER.KUNDEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','Tholler','Andreas','m','K�ln','Belaweg','0221/956788',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','Falk','Bernhardt','m','K�ln','Auf dem H�gel','0221/2345690',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','M�ller','Tobias','m','K�ln','Bennstr','0221/5566123',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Franz','Helga','w','K�ln','Bahnhofstr.','0221/5566901',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('5','S�ndbald','Hannelore','w','Gummersbach','Luisenstr','02261/4588',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('6','Wal','Birgit','w','Gummersbach','L�h','02261/4471',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('7','Tisch','Hartmut','m','Gladbeck','Agathastr.','02271/75613',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.KUNDEN_LEON
SET DEFINE OFF;
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','Tholler','Andreas','m','K�ln','Belaweg','0221/956788',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','Falk','Bernhardt','m','K�ln','Auf dem H�gel','0221/2345690',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','M�ller','Tobias','m','K�ln','Bennstr','0221/5566123',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Franz','Helga','w','K�ln','Bahnhofstr.','0221/5566901',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('5','S�ndbald','Hannelore','w','Gummersbach','Luisenstr','02261/4588',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('6','Wal','Birgit','w','Gummersbach','L�h','02261/4471',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('7','Tisch','Hartmut','m','Gladbeck','Agathastr.','02271/75613',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.LAGER
SET DEFINE OFF;
Insert into PLSQLTRAINER.LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('1','HauptLager','K�ln','Eibenweg');
Insert into PLSQLTRAINER.LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('2','NebenLager','Gummersbach','Am Sandberg');
Insert into PLSQLTRAINER.LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('3','VerladeLager','Dortmund','Hansastr.');
REM INSERTING into PLSQLTRAINER.LAGERBESTAND
SET DEFINE OFF;
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','1','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','31','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','57','1000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','55','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','56','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','57','1000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','1','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','31','2000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','54','1000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','60','899',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','61','1000',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','1','4000',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.LIEFERANTEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','West-Ost-Handel','K�ln','Eibenweg','0221/985688',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','IMPORT-Wendel','Dortmund','K�lner Str.','0221/76499',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','Quarks','Gummersbach','M�hle','02261/6711',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Wahle','Remscheid','Lenneperstr.',null,to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.LIEFERPROGRAMME
SET DEFINE OFF;
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','3','7','2','5',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','4','9','5','6',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','5','11','1230','7',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','24','49','18','26',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','7','15','18','9',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','8','17','150','10',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','9','19','5','11',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','10','21','79','12',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','12','25','0,5','14',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','13','27','0,6','15',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','14','29','0,5','16',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','15','31','22','17',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','16','33','28','18',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','17','35','28','19',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','18','37','109','20',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','19','39','10','21',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','20','41','11','22',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','21','43','110','23',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','22','45','60','24',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','28','57','29','30',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','23','47','28','25',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','25','51','149','27',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','26','53','299','28',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','27','55','69','29',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','29','59','1590','31',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','30','61','2590','32',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','33','67','2','35',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','34','69','8','36',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','35','71','30','37',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','36','73','18','38',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','37','75','19','39',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','38','77','252','40',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','39','79','9','41',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','40','81','9','42',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','42','85','0,5','44',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','43','87','0,6','45',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','44','89','0,5','46',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','45','91','22','47',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','46','93','28','48',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','47','95','70','49',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','48','97','140','50',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','49','99','10','51',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','50','101','17','52',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','51','103','150','53',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','52','105','80','54',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','53','107','30','55',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','3','20','12','16',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','4','21','15','15',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','5','22','1240','14',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','7','24','28','12',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','8','25','160','11',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','9','26','15','10',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','10','27','89','9',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','12','29','10,5','7',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','13','30','10,6','6',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','14','31','10,5','5',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','15','32','32','4',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','16','33','38','3',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','17','34','38','2',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','18','35','119','1',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','19','36','20','0',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','20','37','21','1',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','21','38','120','2',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','22','39','70','3',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','23','40','38','4',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','24','41','28','5',to_date('28.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','33','297','2,2','59',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','34','306','8,8','61',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','35','315','33','63',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','36','324','19,8','65',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','37','333','20,9','67',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','38','342','277,2','69',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','39','351','9,9','71',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','40','360','9,9','73',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','42','378','0,55','77',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','43','387','0,66','79',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','44','396','0,55','81',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','45','405','24,2','83',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','46','414','30,8','85',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','47','423','77','87',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','48','432','154','89',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','49','441','11','91',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','50','450','18,7','93',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','51','459','165','95',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','52','468','88','97',to_date('29.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','53','477','33','99',to_date('29.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.LIEFERUNGEN
SET DEFINE OFF;
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('1','1','12',to_date('19.09.18','DD.MM.RR'),'1',to_date('08.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('2','1','13',to_date('19.09.18','DD.MM.RR'),'1',to_date('09.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('3','1','14',to_date('19.09.18','DD.MM.RR'),'1',to_date('10.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('4','1','15',to_date('19.09.18','DD.MM.RR'),'1',to_date('11.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('5','1','16',to_date('19.09.18','DD.MM.RR'),'1',to_date('12.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('6','1','17',to_date('19.09.18','DD.MM.RR'),'1',to_date('13.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('7','1','18',to_date('19.09.18','DD.MM.RR'),'1',to_date('14.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('8','1','19',to_date('19.09.18','DD.MM.RR'),'1',to_date('15.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('9','1','20',to_date('19.09.18','DD.MM.RR'),'1',to_date('16.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('10','1','21',to_date('19.09.18','DD.MM.RR'),'1',to_date('17.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('11','1','22',to_date('19.09.18','DD.MM.RR'),'1',to_date('18.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('12','1','23',to_date('19.09.18','DD.MM.RR'),'1',to_date('19.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('13','1','24',to_date('19.09.18','DD.MM.RR'),'1',to_date('20.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('14','2','24',to_date('18.09.18','DD.MM.RR'),'2',to_date('20.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('15','2','12',to_date('18.09.18','DD.MM.RR'),'2',to_date('08.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('16','2','13',to_date('18.09.18','DD.MM.RR'),'2',to_date('09.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('17','2','14',to_date('18.09.18','DD.MM.RR'),'2',to_date('10.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('18','2','15',to_date('18.09.18','DD.MM.RR'),'2',to_date('11.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('19','2','16',to_date('18.09.18','DD.MM.RR'),'2',to_date('12.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('20','2','17',to_date('18.09.18','DD.MM.RR'),'2',to_date('13.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('21','2','18',to_date('18.09.18','DD.MM.RR'),'2',to_date('14.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('22','2','19',to_date('18.09.18','DD.MM.RR'),'2',to_date('15.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('23','2','20',to_date('18.09.18','DD.MM.RR'),'2',to_date('16.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('24','2','21',to_date('18.09.18','DD.MM.RR'),'2',to_date('17.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('25','2','22',to_date('18.09.18','DD.MM.RR'),'2',to_date('18.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('26','2','28',to_date('18.09.18','DD.MM.RR'),'2',to_date('24.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('27','2','23',to_date('18.09.18','DD.MM.RR'),'2',to_date('19.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('28','2','25',to_date('18.09.18','DD.MM.RR'),'2',to_date('21.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('29','2','26',to_date('18.09.18','DD.MM.RR'),'2',to_date('22.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('30','2','27',to_date('18.09.18','DD.MM.RR'),'2',to_date('23.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('31','2','29',to_date('18.09.18','DD.MM.RR'),'2',to_date('25.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('32','2','30',to_date('18.09.18','DD.MM.RR'),'2',to_date('26.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('33','2','33',to_date('18.09.18','DD.MM.RR'),'2',to_date('29.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('34','2','34',to_date('18.09.18','DD.MM.RR'),'2',to_date('30.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('35','2','35',to_date('18.09.18','DD.MM.RR'),'2',to_date('31.08.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('36','2','36',to_date('18.09.18','DD.MM.RR'),'2',to_date('01.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('37','2','37',to_date('18.09.18','DD.MM.RR'),'2',to_date('02.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('38','2','38',to_date('18.09.18','DD.MM.RR'),'2',to_date('03.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('39','2','39',to_date('18.09.18','DD.MM.RR'),'2',to_date('04.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('40','2','40',to_date('18.09.18','DD.MM.RR'),'2',to_date('05.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('41','2','42',to_date('18.09.18','DD.MM.RR'),'2',to_date('07.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('42','2','43',to_date('18.09.18','DD.MM.RR'),'2',to_date('08.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('43','2','44',to_date('18.09.18','DD.MM.RR'),'2',to_date('09.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('44','2','45',to_date('18.09.18','DD.MM.RR'),'2',to_date('10.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('45','2','46',to_date('18.09.18','DD.MM.RR'),'2',to_date('11.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('46','2','47',to_date('18.09.18','DD.MM.RR'),'2',to_date('12.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('47','2','48',to_date('18.09.18','DD.MM.RR'),'2',to_date('13.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('48','2','49',to_date('18.09.18','DD.MM.RR'),'2',to_date('14.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('49','2','50',to_date('18.09.18','DD.MM.RR'),'2',to_date('15.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('50','2','51',to_date('18.09.18','DD.MM.RR'),'2',to_date('16.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('51','2','52',to_date('18.09.18','DD.MM.RR'),'2',to_date('17.09.18','DD.MM.RR'));
Insert into PLSQLTRAINER.LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('52','2','53',to_date('18.09.18','DD.MM.RR'),'2',to_date('18.09.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.ORA_ERROR
SET DEFINE OFF;
Insert into PLSQLTRAINER.ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-922',null,null,'ORA-00922: Fehlende oder ung�ltige Option');
Insert into PLSQLTRAINER.ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-1031',null,null,'ORA-01031: Nicht ausreichende Berechtigungen');
Insert into PLSQLTRAINER.ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-900',null,null,'ORA-00900: Ung�ltige SQL-Anweisung');
REM INSERTING into PLSQLTRAINER.ORTE
SET DEFINE OFF;
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Gummersbach','L�h',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Gladbeck','Agathastr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('K�ln','Bennstr',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Gummersbach','Luisenstr',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('K�ln','Belaweg',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('K�ln','Bahnhofstr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('K�ln','Auf dem H�gel',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Leverkusen','Netzestr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Falkenstr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Prellerstr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Grubenfeld',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Burgstr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Planckstr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Plutostr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Bedastr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Erntestr.',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Fichtenweg',null);
Insert into PLSQLTRAINER.ORTE (ORT,STRASSE,PLZ) values ('Leverkusen','Quarzstr.',null);
REM INSERTING into PLSQLTRAINER.OUTPUT_TABLE
SET DEFINE OFF;
REM INSERTING into PLSQLTRAINER.POSITIONSARCHIV
SET DEFINE OFF;
REM INSERTING into PLSQLTRAINER.PROC_CALLS
SET DEFINE OFF;
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','1','parameter(''EinTest'')');
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','1','hello_world');
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','1','transform_name(''Peter'',''Meier'')');
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','1','jahre');
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','1','gehaltsnachteile');
Insert into PLSQLTRAINER.PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','1','nachnamen');
REM INSERTING into PLSQLTRAINER.PROC_QUESTIONS
SET DEFINE OFF;
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('4','Schreiben Sie eine Prozedur mit dem Namen "parameter", die einen ihr �bergebenen String ausgibt.','output_table','parameter','CREATE OR REPLACE PROCEDURE parameter (p1 VARCHAR2)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE(p1);
END;','procedure
','output_table');
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('5','Schreiben Sie eine Prozedur mit dem Namen "transform_name", der zwei Textvariablen f�r Nachname und Vorname �bergeben werden und die als Ergebnis beide Variable hintereinandergeschrieben (Nachname, Vorname), getrennt durch ein Komma und in Gro�buchstaben umgewandelt wieder ausgibt!','output_table','transform_name','CREATE OR REPLACE PROCEDURE transform_name (p_vorname  IN VARCHAR2, p_nachname  IN VARCHAR2)
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(UPPER(p_nachname)||'', ''||UPPER(p_vorname));
END;','procedure','output_table');
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('3','Schreiben Sie eine Prozedur mit dem Namen "jahre", die alle Angestellten (Vorname, Nachname ) der letzten 25 Jahre getrennt durch ein Komma und ein Blank, ausgibt. Benutzte Spalte: Eintrittsdatum. Benutzen Sie dabei einen Cursor und ber�cksichtigen Sie, dass die Differenz von zwei Date-Spalten in Tagen ausgegeben wird!','output_table','jahre','create or replace PROCEDURE jahre
IS
   CURSOR c_angestellte
   IS
      SELECT nachname, vorname
        FROM angestellte
       WHERE eintrittsdatum >= SYSDATE - 25 * 360;

   v_nachname   angestellte.nachname%TYPE;
   v_vorname    angestellte.vorname%TYPE;
BEGIN
   OPEN c_angestellte;
   FETCH c_angestellte INTO v_nachname, v_vorname;
   WHILE c_angestellte%FOUND
   LOOP
      DBMS_OUTPUT.PUT_LINE (v_vorname || '', '' || v_Nachname);
      FETCH c_angestellte INTO v_nachname, v_vorname;
   END LOOP;

   CLOSE c_angestellte;
END;
','procedure','angestellte,output_table');
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('6','Schreiben Sie eine PL/SQL-Prozedur mit dem Namen "hello_world", die "Hello World" ausgibt.','output_table','hello_world','CREATE PROCEDURE hello_world
IS
BEGIN
DBMS_OUTPUT.PUT_LINE(''Hello World'');
END;','procedure','output_table');
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('1','Schreiben Sie eine Prozedur mit dem Namen "gehaltsnachteile", die alle Nachnamen von Frauen ausgibt, die bei Aus�bung des gleichen Berufs ein geringeres Gehalt als ein Mann haben.
Die Prozedur sollte zeilenweise "Frauenname"  "M�nnername" ausgeben.','output_table','gehaltsnachteile','CREATE OR REPLACE PROCEDURE gehaltsnachteile IS
V_frauenname VARCHAR2(50);
V_maennername VARCHAR2(50);
CURSOR geh_nachteile IS SELECT f.nachname Fnachname,
                   m.nachname Mnachname
                   FROM angestellte f, angestellte m
                   WHERE UPPER(f.geschlecht) = ''W''
                   AND UPPER(m.geschlecht) = ''M''
                   AND m.beruf = f.beruf
                   AND f.gehalt < m.gehalt;
BEGIN
OPEN geh_nachteile;
FETCH geh_nachteile INTO V_frauenname, V_maennername;
WHILE geh_nachteile%FOUND LOOP
DBMS_OUTPUT.PUT_LINE(V_frauenname|| '' '' || V_maennername);
FETCH geh_nachteile INTO V_frauenname, V_maennername;
END LOOP;
CLOSE geh_nachteile;
END;','procedure','angestellte,output_table');
Insert into PLSQLTRAINER.PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('2','Schreiben Sie eine Prozedur mit dem Namen "angestellte", die zuerst den Text "Nachnamen"  ausgibt, und danach alle Nachnamen aus der Tabelle "angestellte".','output_table','nachnamen','CREATE OR REPLACE PROCEDURE nachnamen IS
nachname VARCHAR2(50);
CURSOR namen IS SELECT nachname FROM angestellte;
BEGIN
DBMS_OUTPUT.PUT_LINE(''Nachnamen'');
OPEN namen;
FETCH namen INTO nachname;
WHILE namen%FOUND LOOP
DBMS_OUTPUT.PUT_LINE(nachname);
FETCH namen INTO nachname;
END LOOP;
CLOSE namen;
END;','procedure','angestellte,output_table');
REM INSERTING into PLSQLTRAINER.QUESTIONS
SET DEFINE OFF;
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('11','Erstellen Sie einen Trigger mit dem Namen "trg_view_rechnung" auf der View "Rechnungen", welcher die Menge in der Tabelle "Auftragspositionen" anpasst, wenn versucht wird, dieses Feld in der View selber zu �ndern.','Auftragspositionen','trg_view_rechnung','CREATE OR REPLACE TRIGGER trg_view_rechnung
  INSTEAD OF UPDATE  ON Rechnungen
DECLARE
BEGIN
   UPDATE Auftragspositionen
    SET MENGE = :NEW.MENGE
WHERE AUFTRAGSNR = :NEW.AUFTRAGSNR AND TNR = :NEW.TNR ;

END;','Trigger - View','Rechnungen,Auftragspositionen');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('12','Erstellen Sie einen Trigger mit dem Namen "trg_view_auftrag" auf der View "Rechnungen", welcher einen neuen Eintrag in der Tabelle Auftragspositionen macht, wenn versucht wird, in der View einen neuen Datensatz anzulegen.','Auftragspositionen','trg_view_auftrag','CREATE OR REPLACE TRIGGER trg_view_auftrag
  INSTEAD OF INSERT ON Rechnungen
   DECLARE
   BEGIN

   INSERT INTO Auftragspositionen VALUES
      ( :NEW.TNR, :NEW.AUFTRAGSNR, :NEW.MENGE);

END;','Trigger - View','Rechnungen,Auftragspositionen');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('2','Abteilungsleiter m�ssen einer Mindestgehaltsgruppe angeh�ren.
Beim Hinzuf�gen einer neuen Abteilung oder wenn sich der Leiter einer Abteilung �ndert soll mit dem Trigger "trg_leiter_gehalt" gepr�ft werden, ob das Gehalt des Abteilungleiters mindestens in die Gehaltsgruppe 3 f�llt. Ist das Gehalt zu niedrig, so soll es auf das Mindestgehalt dieser Gehaltsgruppe erh�ht werden.','Angestellte','trg_leiter_gehalt','create or replace TRIGGER trg_leiter_gehalt
AFTER INSERT OR UPDATE ON ABTEILUNGEN
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
  geh number;
  gehmin number;
BEGIN
  select gehalt into geh from angestellte where ang_nr=:neu.leiter;
  select min_gehalt into gehmin from geh_klassen where geh_klasse=3;
  if (geh < gehmin) then
    update angestellte set gehalt=gehmin where ang_nr=:neu.leiter;
  END IF;
END;','Trigger - Tabelle','Angestellte,Abteilungen,Geh_klassen');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('3','Folgeverarbeitung bei Bestands�nderung.
Wenn sich der Bestand eines Teils in der Tabelle Lagerbestand �ndert, soll der Bestand in der Tabelle Teile automatisch mit angepasst werden. Der Trigger soll
unter dem Namen "trg_bestand_update" erstellt werden.','Teile','trg_bestand_update','CREATE OR REPLACE TRIGGER trg_bestand_update
AFTER UPDATE OF Bestand ON Lagerbestand
FOR EACH ROW
BEGIN
	UPDATE Teile
	SET Bestand =:NEW.Bestand -:OLD.Bestand + Bestand
	WHERE TNr =:NEW.TNr;
END;','Trigger - Tabelle','Teile,Lagerbestand');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('1','Die Summer aller Geh�lter darf ein bestimmtes Budget nicht �berschreiten.

Es soll ein Trigger "trg_budget_check" erstellt werden, der beim Hinzuf�gen eines neuen Mitarbeiters in der
Tabelle "Angestellte" und gleichzeitigem �berschreitung eines Gesamtbudgets von 100.000� der Abteilung angestossen wird. In diesem Fall sollen alle Geh�lter, die h�her als 5000� sind, auf 5000� gek�rzt werden.','Angestellte','trg_budget_check','create or replace TRIGGER trg_budget_check
AFTER INSERT ON Angestellte
DECLARE
   v_sum NUMBER;
BEGIN
SELECT SUM(gehalt) INTO v_sum FROM Angestellte;
IF v_sum > 100000 THEN
UPDATE Angestellte SET gehalt=5000 where gehalt > 5000;
END IF;
END;','Trigger - Tabelle','Angestellte');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('4','Folgeverarbeitung vollst�ndig bezahlter Rechnungen.
Der Trigger "trg_umsatz_update" soll, sobald ein Kunde den Rechnungsbetrag eines Auftrags vollst�ndig
gezahlt hat, in der Tabelle Artikel die im Auftrag umgesetzten Mengen zum Jahresumsatz hinzu addieren.','Artikel','trg_umsatz_update','CREATE OR REPLACE TRIGGER trg_umsatz_update
BEFORE INSERT OR UPDATE ON AUFTRAEGE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
rechnungssumme number;
BEGIN
  if (:alt.bereits_gezahlt <> :neu.bereits_gezahlt) then
    select SUM(Gesamt) into rechnungssumme from (select auftragspositionen.tnr,auftragspositionen.menge,artikel.verkaufspreis,
    (auftragspositionen.menge*artikel.verkaufspreis) as gesamt  from auftragspositionen inner join
    artikel on auftragspositionen.tnr=artikel.tnr where auftragspositionen.auftragsnr=:neu.auftragsnr);
    if (rechnungssumme = :neu.bereits_gezahlt) then
      update artikel set jahresumsatz=jahresumsatz + (select menge from auftragspositionen where AUFTRAGSNR=:neu.auftragsnr
      and auftragspositionen.TNR = Artikel.TNR) where tnr in (select tnr from auftragspositionen where auftragsnr=:neu.auftragsnr);
    end if;
  end if;
END;','Trigger - Tabelle','Artikel,Auftraege,Auftragspositionen');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('5','Gehaltserh�hungen m�ssen mindestens in einer H�he von 10% erfolgen.
Bei Erh�hung des Gehalts eines Angestellten soll durch den Trigger "trg_erh_gehalt" gepr�ft werden, ob diese
Regelung eingehalten wurde. Sollte der neue Wert zu niedrig sein, soll das Gehalt des Angestellten
automatisch um dieses Minimum erh�ht werden. ','Angestellte','trg_erh_gehalt','CREATE OR REPLACE TRIGGER trg_erh_gehalt
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
erh number;
erh_min number;
BEGIN
  if (:alt.gehalt < :neu.gehalt) then
    erh := :neu.gehalt - :alt.gehalt;
    erh_min := :alt.gehalt * 0.1;
    if (erh < erh_min) then
      :neu.gehalt := :alt.gehalt + erh_min;
    end if;
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('6','Archivierung gel�schter Auftragspositionen.
Wenn ein Datensatz aus der Tabelle "Auftragspositionen" gel�scht wird, sollen die gel�schten Datens�tz durch den
Trigger "trg_pos_archiv" in der Tabelle "Positionsarchiv" archiviert werden.','Positionsarchiv','trg_pos_archiv','CREATE OR REPLACE TRIGGER trg_pos_archiv
AFTER DELETE ON AUFTRAGSPOSITIONEN
REFERENCING OLD AS alt
FOR EACH ROW
BEGIN
  insert into POSITIONSARCHIV values (:alt.auftragsnr, :alt.tnr, :alt.menge);
END;','Trigger - Tabelle','Auftragspositionen,Positionsarchiv');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('7','Protokollierung von Gehalts�nderungen.
Wenn in der Tabelle Angestellte �nderungen in der Spalte "Gehalt" vorgenommen werden, soll die betreffende Ang_Nr, die Gehaltsver�nderung d.h. altes Gehalt und neues Gehalt sowie das aktuelle Tagesdatum, durch den Trigger "trg_geh_prot", in der Tabelle "Gehaltsprotokoll" protokolliert werden.

Info: Aktuelles Tagesdatum �ber TO_CHAR(sysdate) einf�gen.','Gehaltsprotokoll','trg_geh_prot','CREATE OR REPLACE TRIGGER trg_geh_prot
AFTER UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:alt.gehalt <> :neu.gehalt) then
    insert into GEHALTSPROTOKOLL values (:alt.ang_nr, :alt.gehalt , :neu.gehalt , TO_CHAR(sysdate));
  end if;
END;','Trigger - Tabelle','Angestellte,Gehaltsprotokoll');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('8','Geh�lter d�rfen nicht sinken.
Durch den Trigger "trg_geh_check" soll sichergestellt werden,  dass in der Spalte Gehalt in der Tabelle
"Angestellte"  kein niedrigerer Wert als der bisherige eingetragen wird. In diesem Fall soll eine
Ausnahme mit der ID:-20001 und dem Text:"Geh�lter d�rfen nicht sinken" ausgel�st werden.','exception','trg_geh_check','CREATE OR REPLACE TRIGGER trg_geh_check
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:neu.gehalt < :alt.gehalt) then
    RAISE_APPLICATION_ERROR(-20001,''Geh�lter d�rfen nicht sinken'');
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('9','Personalnummern d�rfen nicht ge�ndert werden.
Durch den Trigger "trg_ang_nr_check" soll verhindert werden, dass die Spalte "Ang_Nr" in der Tabelle
Angestellte nachtr�glich ge�ndert wird. In diesem Fall soll eine Ausnahme mit der ID:-20001 und
dem Text:"Personalnummern d�rfen nicht ge�ndert werden" ausgel�st werden.','exception','trg_ang_nr_check','CREATE OR REPLACE TRIGGER trg_ang_nr_check
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:neu.ang_nr <> :alt.ang_nr) then
    RAISE_APPLICATION_ERROR(-20001,''Personalnummern d�rfen nicht ge�ndert werden'');
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into PLSQLTRAINER.QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('10','Gehaltsklassen d�rfen sich nicht �berschneiden.
Der Trigger "trg_geh_klassen" soll beim Einf�gen/�ndern eines Datensatzes in der Tabelle geh_klassen die neuen bzw. ge�nderten Zeilen pr�fen, ob sich hierdurch �berschneidungen
zu anderen Gehaltsklassen ergeben. Sollte dies der Fall sein, soll der Trigger eine Exception mit der ID: -20001 und dem Text: "Gehaltsklassen d�rfen sich nicht �berschneiden" ausl�sen.
(Tipp: Verwenden Sie zur L�sung einen autonomen Row-Trigger)','exception','trg_geh_klassen','CREATE OR REPLACE TRIGGER trg_geh_klassen
   BEFORE INSERT OR UPDATE
   ON geh_klassen
   FOR EACH ROW
DECLARE
   v_anzahl   NUMBER (5) DEFAULT 0;
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   SELECT   COUNT ( * )
     INTO   v_anzahl
     FROM   geh_klassen
    WHERE   (:NEW.min_gehalt BETWEEN min_gehalt AND max_gehalt
             OR :NEW.max_gehalt BETWEEN min_gehalt AND max_gehalt);
   COMMIT;
   IF v_anzahl > 1
   THEN
      RAISE_APPLICATION_ERROR (
         -20001,''Gehaltsklassen d�rfen sich nicht �berschneiden'');
   END IF;
END;','Trigger - Tabelle','Geh_klassen');
REM INSERTING into PLSQLTRAINER.STRUKTUR
SET DEFINE OFF;
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','2','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('2','3','2','10','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('2','4','3','20','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','5','4','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','24','5','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','7','6','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','8','7','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','9','8','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','10','9','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','11','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','16','11','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','17','12','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','18','13','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','19','14','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','20','15','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','21','16','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','22','17','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','23','18','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','12','1','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','13','2','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','14','3','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','15','4','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','32','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('32','33','2','10','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('32','34','3','20','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','35','4','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','44','5','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','37','6','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','38','7','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','39','8','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','40','9','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','41','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','46','11','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','47','12','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','48','13','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','49','14','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','50','15','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','51','16','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','52','17','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','53','18','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','42','1','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','43','2','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','44','3','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','45','4','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','2','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','41','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','62','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('62','49','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('62','40','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('40','34','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('40','3','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.TEILE
SET DEFINE OFF;
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('1','St�ck','Rocky Mountain Element Race','Artikel','2600','0','10','8000','20','20','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('2','St�ck','Rahmen Element Race','Baugruppe','300','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('3','kg','Silberfarbe','Material','0','2','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('4','kg','Sintermetall','Material','0','5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('5','St�ck','Gabel SID XC','Material','0','1230','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('24','St�ck','TretLager Race Face','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('7','St�ck','Kurbelsatz Race Face','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('8','St�ck','Schaltwerk XTR','Material','0','150','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('9','St�ck','Pedale Shimano 747','Material','0','5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('10','St�ck','Schalthebel Grip Shift','Material','0','79','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('11','St�ck','Rad xtr','Baugruppe','50','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('12','St�ck','Naben Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('13','St�ck','Felgen Mavic Crossmax','Material','0','0,6','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('14','St�ck','Speichen Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('15','St�ck','Bereifung Richtey, Vo: Z-Max ','Material','0','22','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('16','St�ck','Steuersatz Chris King','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('17','St�ck','Vorbau Control Tech','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('18','St�ck','Lenker Answer Hyperlite','Material','0','109','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('19','St�ck','Griffe LGrip Shift ','Material','0','10','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('20','St�ck','Bremshebel XTR','Material','0','11','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('21','St�ck','Bremsen XTR','Material','0','110','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('22','St�ck','Sattel Flite','Material','0','60','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('28','St�ck','Bremse Shimano Alivio Cantilever ','Material','0','29','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('23','St�ck','Sattelst�tze Syncros','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('25','St�ck','Bremse Shimano XTR V-Brake ','Material','0','149','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('26','St�ck','GABEL TOP GUN ','Material','0','299','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('27','St�ck','Shimano STX-RC i','Material','0','69','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('29','St�ck','Rahmen Cannondale CAD3 Headshok','Material','0','1590','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('30','St�ck','Rahmen Super V','Material','0','2590','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('31','St�ck','Herrenrad GT-LTS 18','Artikel','3000','0','10','4000','20','20','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('32','St�ck','Rahmen GT-LTS 18"','Baugruppe','300','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('33','kg','Vb-Farbe','Material','0','2','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('34','kg','Aluminium','Material','0','8','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('35','St�ck','RST Hi-5','Material','0','30','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('36','St�ck','Race Face (TITAN)','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('37','St�ck','Kurbelsatz Ritchey Logic','Material','0','19','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('38','St�ck','Schaltwerk XTR inverse','Material','0','252','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('39','St�ck','Pedale XT','Material','0','9','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('40','St�ck','Schalthebel Grip Shift 4','Material','0','9','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('41','St�ck','Rad XTR 47','Baugruppe','60','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('42','St�ck','Naben Inferno','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('43','St�ck','Felgen Inferno','Material','0','0,6','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('44','St�ck','Speichen Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('45','St�ck','Bereifung Continental ','Material','0','22','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('46','St�ck','Steuersatz Race Face','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('47','St�ck','Vorbau Syncros','Material','0','70','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('48','St�ck','Lenker Syncros (Downhill)','Material','0','140','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('49','St�ck','Griffe LGrip Shift ','Material','0','10','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('50','St�ck','Bremshebel TWP G-Force','Material','0','17','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('51','St�ck','Bremsen Magura Race Line','Material','0','150','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('52','St�ck','Sattel Selle Flite Titanium','Material','0','80','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('53','St�ck','Sattelst�tze XTR','Material','0','30','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('54','St�ck','Klapprad Prompton P3','Artikel','0','1200','10','1000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('55','St�ck','CANNONDALE FSL','Artikel','0','4200','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('56','St�ck','HERCULES NEPAL','Artikel','0','1200','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('57','St�ck','Steppenwolf TAO','Artikel','0','1600','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('58','St�ck','SWITCHBACK AGENT','Artikel','0','599','10','2697','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('59','St�ck','STEVENS R.P.R.2 RX100 8FACH','Artikel','0','1700','10','10','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('60','St�ck','Scott ATACAMA TOUR','Artikel','0','1899','10','899','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('61','St�ck','ROTWILD RCC-03','Artikel','0','3280','10','1000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into PLSQLTRAINER.TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('62','St�ck','Lenker','Baugruppe','0','280','10','10','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into PLSQLTRAINER.TEILE_WERKE
SET DEFINE OFF;
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('2','1');
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('2','2');
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('11','1');
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('32','1');
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('41','1');
Insert into PLSQLTRAINER.TEILE_WERKE (TNR,WNR) values ('41','2');
REM INSERTING into PLSQLTRAINER.WERKE
SET DEFINE OFF;
Insert into PLSQLTRAINER.WERKE (WNR,BEZEICHNUNG,ORT,STRASSE) values ('1','Montagewerk','Gladbeck','Adlerstr.');
Insert into PLSQLTRAINER.WERKE (WNR,BEZEICHNUNG,ORT,STRASSE) values ('2','Vorfertigung','Gladbeck','Am Pferdekamp');
--------------------------------------------------------
--  DDL for Index ABT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."ABT_PK" ON "PLSQLTRAINER"."ABTEILUNGEN" ("ABT_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index ANG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."ANG_PK" ON "PLSQLTRAINER"."ANGESTELLTE" ("ANG_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FIRINGSTATEMENTS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."FIRINGSTATEMENTS_PK" ON "PLSQLTRAINER"."FIRINGSTATEMENTS" ("QUESTIONID", "EXECORDER")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FUNC_QUESTIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."FUNC_QUESTIONS_PK" ON "PLSQLTRAINER"."FUNC_QUESTIONS" ("QUESTIONID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index GE_PRO_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."GE_PRO_PK" ON "PLSQLTRAINER"."GEHALTSPROTOKOLL" ("ANG_NR", "DATUM")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index G_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."G_PK" ON "PLSQLTRAINER"."GEH_KLASSEN" ("GEH_KLASSE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index KUN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."KUN_PK" ON "PLSQLTRAINER"."KUNDEN" ("KUN_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LAG_PK" ON "PLSQLTRAINER"."LAGER" ("LANR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LAG_T_PK" ON "PLSQLTRAINER"."LAGERBESTAND" ("LANR", "TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LEON_KUN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LEON_KUN_PK" ON "PLSQLTRAINER"."KUNDEN_LEON" ("KUN_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LG_PK" ON "PLSQLTRAINER"."LIEFERUNGEN" ("LIEFER_NR", "LIEF_NR", "TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LIEF_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LIEF_PK" ON "PLSQLTRAINER"."LIEFERANTEN" ("LIEF_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."LP_PK" ON "PLSQLTRAINER"."LIEFERPROGRAMME" ("LIEF_NR", "TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index O_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."O_PK" ON "PLSQLTRAINER"."ORTE" ("ORT", "STRASSE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."PA_PK" ON "PLSQLTRAINER"."POSITIONSARCHIV" ("TNR", "AUFTRAGSNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index QUESTIONS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."QUESTIONS_PK" ON "PLSQLTRAINER"."QUESTIONS" ("QUESTIONID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index S_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."S_PK" ON "PLSQLTRAINER"."STRUKTUR" ("OTEIL", "UTEIL", "POSITION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index TE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."TE_PK" ON "PLSQLTRAINER"."TEILE" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."T_WE_PK" ON "PLSQLTRAINER"."TEILE_WERKE" ("TNR", "WNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index WE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."WE_PK" ON "PLSQLTRAINER"."WERKE" ("WNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."AR_AU_PK" ON "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ("TNR", "AUFTRAGSNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."AR_PK" ON "PLSQLTRAINER"."ARTIKEL" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "PLSQLTRAINER"."AU_PK" ON "PLSQLTRAINER"."AUFTRAEGE" ("AUFTRAGSNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_LIEF_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LG_LIEF_FK_I" ON "PLSQLTRAINER"."LIEFERUNGEN" ("LIEF_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_T_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LAG_T_T_FK_I" ON "PLSQLTRAINER"."LAGERBESTAND" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index KUNDEN_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."KUNDEN_I" ON "PLSQLTRAINER"."KUNDEN" ("VORNAME", "NACHNAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_T_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."T_WE_T_FK_I" ON "PLSQLTRAINER"."TEILE_WERKE" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_LAG_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LAG_T_LAG_FK_I" ON "PLSQLTRAINER"."LAGERBESTAND" ("LANR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_ANG_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."AU_ANG_FK_I" ON "PLSQLTRAINER"."AUFTRAEGE" ("ANG_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_AR_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."AR_AU_AR_FK_I" ON "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_T_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LP_T_FK_I" ON "PLSQLTRAINER"."LIEFERPROGRAMME" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_LIEF_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LP_LIEF_FK_I" ON "PLSQLTRAINER"."LIEFERPROGRAMME" ("LIEF_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_WE_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."T_WE_WE_FK_I" ON "PLSQLTRAINER"."TEILE_WERKE" ("WNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index ANG_ABT_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."ANG_ABT_FK_I" ON "PLSQLTRAINER"."ANGESTELLTE" ("ABT_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_AU_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."AR_AU_AU_FK_I" ON "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ("AUFTRAGSNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index STRUKTUR_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."STRUKTUR_I" ON "PLSQLTRAINER"."STRUKTUR" ("OTEIL", "UTEIL")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_KUN_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."AU_KUN_FK_I" ON "PLSQLTRAINER"."AUFTRAEGE" ("KUN_NR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_T_FK_I
--------------------------------------------------------

  CREATE INDEX "PLSQLTRAINER"."LG_T_FK_I" ON "PLSQLTRAINER"."LIEFERUNGEN" ("TNR")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Procedure WI2630_GEHALTSNACHTEILE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "PLSQLTRAINER"."WI2630_GEHALTSNACHTEILE" WI2630_GEHALTSNACHTEILE
IS
   V_GEHALT   ANGESTELLTE_WI2630.GEHALT%TYPE;
   CURSOR TAB_CUR IS SELECT TABLE_NAME
                       FROM USER_TABLES;
BEGIN
  OPEN TAB_CUR;
  FETCH TAB_CUR INTO  V_GEHALT;
  WHILE TAB_CUR%FOUND LOOP
  IF V_GEHALT > 5000
  THEN
  EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('WI2630', V_GEHALT);
  FETCH TAB_CUR INTO  V_GEHALT;
  END IF;
  END LOOP;
  CLOSE TAB_CUR;
  END;



/
--------------------------------------------------------
--  DDL for Procedure WI2630_HELLO_WORLD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "PLSQLTRAINER"."WI2630_HELLO_WORLD" WI2630_HELLO_WORLD
IS
BEGIN
EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('WI2630', 'HELLO WORLD');
END;

/
--------------------------------------------------------
--  DDL for Procedure WI2630_SAMPLE_GEHALTSNACHTEILE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "PLSQLTRAINER"."WI2630_SAMPLE_GEHALTSNACHTEILE" IS
V_FRAUENNAME VARCHAR2(50);
V_MAENNERNAME VARCHAR2(50);
CURSOR GEH_NACHTEILE IS SELECT F.NACHNAME FNACHNAME,
                   M.NACHNAME MNACHNAME
                   FROM ANGESTELLTE_SAMPLE_WI2630 F, ANGESTELLTE_SAMPLE_WI2630 M
                   WHERE UPPER(F.GESCHLECHT) = 'W'
                   AND UPPER(M.GESCHLECHT) = 'M'
                   AND M.BERUF = F.BERUF
                   AND F.GEHALT < M.GEHALT;
BEGIN
OPEN GEH_NACHTEILE;
FETCH GEH_NACHTEILE INTO V_FRAUENNAME, V_MAENNERNAME;
WHILE GEH_NACHTEILE%FOUND LOOP
EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('SAMPLE_WI2630', V_FRAUENNAME|| ' ' || V_MAENNERNAME);
FETCH GEH_NACHTEILE INTO V_FRAUENNAME, V_MAENNERNAME;
END LOOP;
CLOSE GEH_NACHTEILE;
END;

/
--------------------------------------------------------
--  DDL for Procedure WI2630_SAMPLE_HELLO_WORLD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "PLSQLTRAINER"."WI2630_SAMPLE_HELLO_WORLD"
IS
BEGIN
EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('SAMPLE_WI2630', 'HELLO WORLD');
END;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PLSQLTRAINER"."EDB_PLSQL_APP" IS

  FUNCTION evaluate_question
        ( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2)
    RETURN sys_refcursor AS
    evaluation_result sys_refcursor;
    sample_trigger VARCHAR(4048);
    new_test_trigger VARCHAR(4048);
    table_name VARCHAR(128);
    l_needed_table VARCHAR(128);
    l_tablen  BINARY_INTEGER;
    l_tab DBMS_UTILITY.uncl_array;
    function_result NUMBER;
    result_diffrence NUMBER;
    message VARCHAR2(512);
    resultnumber NUMBER;
    exceptiontesttable NUMBER;
    exceptionreferencetable NUMBER;
    resulttesttable CLOB;
    resultreferencetable CLOB;
    v_object_type VARCHAR2(32);
  BEGIN

    SELECT SAMPLETRIGGER, UPPER(TESTTABLE), NEEDEDTABLE INTO sample_trigger, table_name, l_needed_table FROM QUESTIONS WHERE QUESTIONID = question_id;

    ---------------------------------------------------------------------
    -- Aufbau der ben�tigten Tabellen f�r den zu pr�fenden Trigger ------
    ---------------------------------------------------------------------

     DBMS_UTILITY.comma_to_table (
     list   => l_needed_table,
     tablen => l_tablen,
     tab    => l_tab);

    FOR i IN 1 .. l_tablen LOOP
        SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
        IF v_object_type = 'TABLE' THEN
            function_result := delete_table_if_exists(UPPER(l_tab(i)),UPPER(identifier_key));
            function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
        ELSIF v_object_type = 'VIEW' THEN
            function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
        END IF;
    END LOOP;

    ---------------------------------------------------------------------
    -- Der zu pr�fende Trigger ------------------------------------------
    ---------------------------------------------------------------------

    new_test_trigger := test_trigger;

    FOR i IN 1 .. l_tablen LOOP
        new_test_trigger := REPLACE(UPPER(new_test_trigger),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
    END LOOP;

    function_result := create_trigger(REPLACE(UPPER(new_test_trigger),'TRIGGER ','TRIGGER '||identifier_key|| '_'),message);
    IF function_result = -1 THEN
        FOR i IN 1 .. l_tablen LOOP
            SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
            IF v_object_type = 'TABLE' THEN
                function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
            ELSIF v_object_type = 'VIEW' THEN
                function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
            END IF;
        END LOOP;

        OPEN evaluation_result FOR
            Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;

        RETURN evaluation_result;
    END IF;

    function_result := fire_trigger(question_id,l_needed_table,identifier_key);
    IF function_result = -1 THEN
        exceptiontesttable := function_result;
    END IF;

    ---------------------------------------------------------------------
    -- Aufbau der ben�tigten Tabellen f�r den Sample Trigger ------------
    ---------------------------------------------------------------------

    FOR i IN 1 .. l_tablen LOOP
        SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
        IF v_object_type = 'TABLE' THEN
            function_result := delete_table_if_exists(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
            function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
        ELSIF v_object_type = 'VIEW' THEN
            function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
        END IF;
    END LOOP;

    ---------------------------------------------------------------------
    -- Der Sample Trigger -----------------------------------------------
    ---------------------------------------------------------------------

    FOR i IN 1 .. l_tablen LOOP
        sample_trigger := REPLACE(UPPER(sample_trigger),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key|| '_res'));
    END LOOP;

    function_result := create_trigger(REPLACE(UPPER(sample_trigger),'TRIGGER ','TRIGGER '||identifier_key|| '_res_'),message);
    IF function_result = -1 THEN
        FOR i IN 1 .. l_tablen LOOP
            SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
            IF v_object_type = 'TABLE' THEN
                function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
            ELSIF v_object_type = 'VIEW' THEN
                function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
            END IF;
        END LOOP;

        OPEN evaluation_result FOR
            Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;

        RETURN evaluation_result;
    END IF;

    function_result := fire_trigger(question_id,l_needed_table,identifier_key || '_res');
    IF function_result = -1 THEN
        exceptionreferencetable := function_result;
    END IF;

    ---------------------------------------------------------------------

    IF table_name <> 'EXCEPTION' THEN
        EXECUTE IMMEDIATE ' select count(*) from(
                            (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || '_res)
                            UNION ALL
                            (select * from ' || table_name || '_' || identifier_key || '_res MINUS select * from ' || table_name || '_' || identifier_key || ')
                            )' INTO result_diffrence;
    ELSE
        IF exceptionreferencetable <> exceptiontesttable THEN
            result_diffrence := -1;
        ELSE
            EXECUTE IMMEDIATE ' select count(*) from(
                                (select * from ' || l_needed_table || '_' || identifier_key || ' MINUS select * from ' || l_needed_table || '_' || identifier_key || '_res)
                                UNION ALL
                                (select * from ' || l_needed_table || '_' || identifier_key || '_res MINUS select * from ' || l_needed_table || '_' || identifier_key || ')
                                )' INTO result_diffrence;
            IF result_diffrence <> 0 THEN
                table_name := l_needed_table;
            END IF;
        END IF;
    END IF;

    IF result_diffrence = 0 THEN
        message := 'Der Trigger hat das gew�nschte Ergebniss zur�ck geliefert!';
        resultnumber := 1;

        OPEN evaluation_result FOR
            SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
    ELSE
        SELECT get_json_fnc('edb_plsql_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
        SELECT get_json_fnc('edb_plsql_app.get_table_data(''' || table_name || '_' || identifier_key || '_res'')') INTO resultreferencetable FROM DUAL;

        message := 'Der Trigger hat das falsche Ergebniss zur�ck geliefert!';
        resultnumber := -1;

        OPEN evaluation_result FOR
            SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
    END IF;

    ---------------------------------------------------------------------
    -- Abbau der ben�tigten Tabellen ------------------------------------
    ---------------------------------------------------------------------

    FOR i IN 1 .. l_tablen LOOP
        SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
        IF v_object_type = 'TABLE' THEN
            function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
        ELSIF v_object_type = 'VIEW' THEN
            function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
        END IF;
    END LOOP;

    FOR i IN 1 .. l_tablen LOOP
        SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
        IF v_object_type = 'TABLE' THEN
            function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
        ELSIF v_object_type = 'VIEW' THEN
            function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
        END IF;
    END LOOP;

    ---------------------------------------------------------------------
    RETURN evaluation_result;

  END evaluate_question;

  FUNCTION create_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
    command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
    EXECUTE IMMEDIATE command;
    EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
  END create_table;

  FUNCTION create_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
    EXECUTE IMMEDIATE command;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
  END create_view;

  FUNCTION delete_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! ('||sqlerrm||')');
  END delete_table;

  FUNCTION delete_table_if_exists
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
        total number(2) := 0;
  BEGIN
    SELECT count(tname) into total from tab where tname = upper(table_name||'_'||identifier_key);
    IF total = 1 THEN
        EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
    END IF;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! ('||sqlerrm||')');
  END delete_table_if_exists;

  FUNCTION delete_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! (' || sqlerrm || ')');
  END delete_view;

  FUNCTION create_trigger
        ( trigger IN VARCHAR2, msg OUT VARCHAR )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE trigger;

    msg:= 'Erfolgreich: Der Trigger wurde ohne Fehler kompiliert!';
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    msg := 'Fehler: Der Trigger konnte nicht kompiliert werden! (' || sqlerrm || ')';
    RETURN -1;
  END create_trigger;

  FUNCTION fire_trigger
    ( question_id IN NUMBER, l_needed_table IN VARCHAR2, identifier_key IN VARCHAR2 )
    RETURN NUMBER AS
    test_statement VARCHAR2(1024);
    l_tablen  BINARY_INTEGER;
    l_tab DBMS_UTILITY.uncl_array;
    CURSOR test_statement_cursor IS
		      SELECT FIRINGCODE
		      FROM FIRINGSTATEMENTS
		      WHERE QUESTIONID = question_id
          ORDER BY EXECORDER ASC;
  BEGIN
     DBMS_UTILITY.comma_to_table (
     list   => l_needed_table,
     tablen => l_tablen,
     tab    => l_tab);

    OPEN test_statement_cursor;
	  LOOP
		  FETCH test_statement_cursor INTO test_statement;
		  EXIT WHEN test_statement_cursor%NOTFOUND;
            FOR i IN 1 .. l_tablen LOOP
                test_statement := REPLACE(UPPER(test_statement),UPPER(l_tab(i)),UPPER(l_tab(i) || '_' || identifier_key));
            END LOOP;
		  EXECUTE IMMEDIATE test_statement;
	  END LOOP;
	  CLOSE test_statement_cursor;
      COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    RETURN 1;
  END fire_trigger;

  FUNCTION get_question
    ( question_id IN NUMBER)
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                QUESTIONTYP ,
                NEEDEDTABLE ,
                TEXT ,
                TESTTABLE ,
                TRIGGERNAME ,
                SAMPLETRIGGER  FROM QUESTIONS WHERE QUESTIONID = question_id;

    RETURN select_result;
  END get_question;

  FUNCTION get_questions
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                QUESTIONTYP ,
                NEEDEDTABLE ,
                TEXT ,
                TESTTABLE ,
                TRIGGERNAME ,
                SAMPLETRIGGER  FROM QUESTIONS ORDER BY QUESTIONID ASC;

    RETURN select_result;
  END get_questions;

  FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

    RETURN select_result;
  END get_table_colum_names;

  FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      'SELECT * FROM ' || v_table_name;

    RETURN select_result;
  END get_table_data;

  FUNCTION get_firing_statements
    ( question_id IN NUMBER )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      SELECT FIRINGCODE
		      FROM FIRINGSTATEMENTS
		      WHERE QUESTIONID = question_id
          ORDER BY EXECORDER ASC;

    RETURN select_result;
  END get_firing_statements;

  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
                                  ,l_num_cols
                                  ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
        LOOP
                CASE
                        WHEN l_descr_tab(i).col_type IN (2
                                         ,8) THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"number"},';
                        WHEN l_descr_tab(i).col_type = 12 THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"date"},';
                        ELSE
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"text"},';
                END CASE;
                dbms_lob.writeappend(l_header_clob
                                    ,length(l_row_data)
                                    ,l_row_data);
        END LOOP;
        l_header_clob := rtrim(l_header_clob
                              ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
                                   ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
                                          ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
                              ,'_x0020_'
                              ,' ');
        dbms_lob.writeappend(l_header_clob
                            ,length(l_ret_clob)
                            ,l_ret_clob);
        RETURN l_header_clob;
EXCEPTION
        WHEN OTHERS THEN
                dbms_output.put_line(SQLERRM);
                dbms_output.put_line(dbms_utility.format_error_backtrace);
                RETURN NULL;
END get_json_fnc;

END edb_plsql_app;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_FUNC_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PLSQLTRAINER"."EDB_PLSQL_FUNC_APP" IS

  FUNCTION create_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
    command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
    EXECUTE IMMEDIATE command;
    EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
  END create_table;

  FUNCTION delete_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    RETURN 1;
    -- raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! ('||sqlerrm||')');
  END delete_table;

   FUNCTION create_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
    EXECUTE IMMEDIATE command;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
  END create_view;

  FUNCTION delete_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! (' || sqlerrm || ')');
  END delete_view;

  FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

    RETURN select_result;
  END get_table_colum_names;

  FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      'SELECT * FROM ' || v_table_name;

    RETURN select_result;
  END get_table_data;

  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
  BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
                                  ,l_num_cols
                                  ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
        LOOP
                CASE
                        WHEN l_descr_tab(i).col_type IN (2
                                         ,8) THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"number"},';
                        WHEN l_descr_tab(i).col_type = 12 THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"date"},';
                        ELSE
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"text"},';
                END CASE;
                dbms_lob.writeappend(l_header_clob
                                    ,length(l_row_data)
                                    ,l_row_data);
        END LOOP;
        l_header_clob := rtrim(l_header_clob
                              ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
                                   ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
                                          ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
                              ,'_x0020_'
                              ,' ');
        dbms_lob.writeappend(l_header_clob
                            ,length(l_ret_clob)
                            ,l_ret_clob);
        RETURN l_header_clob;
  EXCEPTION
        WHEN OTHERS THEN
                dbms_output.put_line(SQLERRM);
                dbms_output.put_line(dbms_utility.format_error_backtrace);
                RETURN NULL;
  END get_json_fnc;

FUNCTION get_questions
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                QUESTIONTYP ,
                NEEDEDTABLE ,
                TEXT ,
                TESTTABLE ,
                FUNCTIONNAME ,
                SAMPLEFUNCTION  FROM FUNC_QUESTIONS ORDER BY QUESTIONID ASC;

    RETURN select_result;
  END get_questions;

  FUNCTION get_question
  ( question_id IN NUMBER)
  RETURN  sys_refcursor AS
  select_result sys_refcursor;
  BEGIN
  OPEN select_result FOR
      SELECT  QUESTIONID ,
              QUESTIONTYP ,
              NEEDEDTABLE ,
              TEXT ,
              TESTTABLE ,
              FUNCTIONNAME ,
              SAMPLEFUNCTION  FROM FUNC_QUESTIONS WHERE QUESTIONID = question_id;

  RETURN select_result;
END get_question;

FUNCTION create_function
      ( function IN VARCHAR2, msg OUT VARCHAR )
  RETURN NUMBER AS
  error VARCHAR2(4000 BYTE);
  func VARCHAR2(1024);
  stmt VARCHAR2(1024);
BEGIN
  func := REGEXP_SUBSTR(function, 'FUNCTION\s*(\w*)', 1, 1, NULL, 1);
  EXECUTE IMMEDIATE function;
  msg:= 'Erfolgreich: Die Funktion wurde ohne Fehler kompiliert!';
  RETURN 1;
EXCEPTION WHEN OTHERS THEN
  stmt := 'SELECT ''Zeile '' || line || '', Spalte '' || position || '' - '' || text FROM USER_ERRORS WHERE NAME = :funcname FETCH FIRST 1 ROWS ONLY';
  EXECUTE IMMEDIATE stmt INTO error USING func;
  msg := 'Fehler: Die Funktion konnte nicht kompiliert werden! (' || sqlerrm || ') - Details: ' || error || ')';
  EXECUTE IMMEDIATE 'DROP FUNCTION ' || func;
  RETURN -1;
END create_function;

FUNCTION delete_function
      ( function_name IN VARCHAR2, msg OUT VARCHAR )
  RETURN NUMBER AS
BEGIN
  EXECUTE IMMEDIATE 'DROP FUNCTION '||function_name;
  msg:= 'Erfolgreich: Die Funktion wurde ohne Fehler gel�scht!';
  RETURN 1;
EXCEPTION WHEN OTHERS THEN
  msg := 'Fehler: Die Funktion konnte nicht gel�scht werden! (' || sqlerrm || ')';
  RETURN -1;
END delete_function;

FUNCTION evaluate_question
    ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2)
  RETURN sys_refcursor AS
  evaluation_result sys_refcursor;
  user_result VARCHAR(4000 BYTE);
  mod_user_function VARCHAR(1024);
  sample_function VARCHAR(1024);
  mod_sample_function VARCHAR(1024);
  table_name VARCHAR(128);
  func_name VARCHAR(128);
  l_needed_table VARCHAR(128);
  l_tablen  BINARY_INTEGER;
  l_tab DBMS_UTILITY.uncl_array;
  function_result NUMBER;
  eval_result VARCHAR2(1024);
  message VARCHAR2(10000 BYTE);
  v_object_type VARCHAR2(32);
  v_func_call VARCHAR2(500);
  v_func_call_user VARCHAR2(500);
  v_func_call_sample VARCHAR2(500);
  result_difference NUMBER;
  resultnumber NUMBER;
  resulttesttable CLOB;
  resultreferencetable CLOB;
  sql_stmt VARCHAR2(512);
CURSOR func_call_cursor IS
        SELECT CALL
        FROM FUNC_CALLS
        WHERE QUESTIONID = question_id
    ORDER BY EXECORDER ASC;
BEGIN

-- select samplefunction (solution) from FUNCTIONQUESTION
SELECT SAMPLEFUNCTION, UPPER(TESTTABLE), FUNCTIONNAME, NEEDEDTABLE INTO sample_function, table_name, func_name, l_needed_table
  FROM FUNC_QUESTIONS WHERE QUESTIONID = question_id;

-- mit komma getrennte liste (l_needed_table) wird hier geparst
DBMS_UTILITY.comma_to_table (
list   => l_needed_table,
tablen => l_tablen,
tab    => l_tab);

FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    END IF;
END LOOP;

-- erstellen der needed tables (identifier_key wird an tabellennamen angehangen)
FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := create_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    ELSIF v_object_type = 'VIEW' THEN
        function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
    END IF;
END LOOP;

-- �bergebene userfunktion muss vorbereitet werden -> mod_user_function
    mod_user_function := user_function;

    -- needed_tables mit identifier_key erweitern
    FOR i IN 1 .. l_tablen LOOP
        mod_user_function := REPLACE(UPPER(mod_user_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
    END LOOP;
    --   dbms_output durch eigenen Funktionsaufruf ersetzen
    -- mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_'||identifier_key||' VALUES');
    mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_func_app.insert_into_output_table('''||identifier_key||''', ' );
    --     DBMS_OUTPUT.PUT_LINE('buffer is: '||buffer);
    -- insert_into_output_table('abcd', 'buffer is: '||buffer);

    -- userfunction mit identifier_key erweitern und kompilieren
    function_result := create_function(REPLACE(UPPER(mod_user_function),'FUNCTION ','FUNCTION '||UPPER(identifier_key)||'_'),message);
    -- return on compilation error
    IF function_result = -1 THEN
        OPEN evaluation_result FOR
            Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        RETURN evaluation_result;
    END IF;


    -- samplefunction mit identifier_key erweitern
    -- dbms_output durch inserts ersetzen
    mod_sample_function := sample_function;

    FOR i IN 1 .. l_tablen LOOP
        mod_sample_function := REPLACE(UPPER(mod_sample_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_SAMPLE_'||identifier_key));
    END LOOP;
    -- mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_SAMPLE_'||identifier_key||' VALUES');
    mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_func_app.insert_into_output_table(''SAMPLE_'||identifier_key||''', ' );
    -- insert_into_output_table('SAMPLE_abcd', 'buffer is: '||buffer);

    -- samplefunction kompilieren
    function_result := create_function(REPLACE(UPPER(mod_sample_function),'FUNCTION ','FUNCTION '||UPPER(identifier_key)||'_SAMPLE_'),message);
    -- return on error (should never happen)
    IF function_result = -1 THEN
        OPEN evaluation_result FOR
            Select -3 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        RETURN evaluation_result;
    END IF;




-- hier m�ssten firingstatements auf beide funktion losgelassen werden
-- example in firingstatements steht:
 --- eur_to_usd(15);
 -- dann wird daraus IDKEY_eur_to_usd(15) und IDKEY_SAMPLE_eur_to_usd(15)

-- get the function calls from the table
--SELECT CALL INTO v_func_call FROM FUNC_CALLS WHERE QUESTIONID = question_id ORDER BY EXECORDER ASC;

OPEN func_call_cursor;
	  LOOP
		  FETCH func_call_cursor INTO v_func_call;
		  EXIT WHEN func_call_cursor%NOTFOUND;
            v_func_call_user := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_'||UPPER(func_name));
            v_func_call_sample := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_SAMPLE_'||UPPER(func_name));

        -- execute function save result in function_result - save return value in output table
		  -- EXECUTE IMMEDIATE v_func_call_user INTO function_result;
          execute immediate 'begin :eval_result := ' ||v_func_call_user|| '; end;' USING OUT eval_result;
          eval_result := v_func_call || ': ' || eval_result;
          sql_stmt := REPLACE('INSERT INTO "PLSQLTRAINER"."OUTPUT_TABLE_XXX" (COLUMN_VALUE) VALUES (:1)','XXX',UPPER(identifier_key));
          EXECUTE IMMEDIATE sql_stmt USING eval_result;

		  --EXECUTE IMMEDIATE v_func_call_sample INTO function_result;
          --function_result := AI1325_SAMPLE_EUR_TO_USD(15);
          execute immediate 'begin :eval_result := ' ||v_func_call_sample|| '; end;' USING OUT eval_result;
          eval_result := v_func_call || ': ' || eval_result;
          sql_stmt := REPLACE('INSERT INTO "PLSQLTRAINER"."OUTPUT_TABLE_SAMPLE_XXX" (COLUMN_VALUE) VALUES (:1)','XXX',UPPER(identifier_key));
          EXECUTE IMMEDIATE sql_stmt USING eval_result;
	  END LOOP;
	  CLOSE func_call_cursor;


-- ergebnisse vergleichen
-- table_name ist in den meisten f�llen (dbms_output) OUTPUT_TABLE

sql_stmt := UPPER(' select count(*) from(
                    (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_SAMPLE_' || identifier_key || ')
                    UNION ALL
                    (select * from ' || table_name || '_SAMPLE_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || ')
                    )');

EXECUTE IMMEDIATE sql_stmt INTO result_difference;

IF result_difference = 0 THEN
        message := 'Die Funktion hat das gew�nschte Ergebnis zur�ckgeliefert!';
        resultnumber := 1;

        OPEN evaluation_result FOR
            SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
ELSE
    SELECT get_json_fnc('edb_plsql_func_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
    SELECT get_json_fnc('edb_plsql_func_app.get_table_data(''' || table_name || '_SAMPLE_' || identifier_key || ''')') INTO resultreferencetable FROM DUAL;

    message := 'Die Funktion hat das falsche Ergebnis zur�ckgeliefert!';
    resultnumber := -1;

    OPEN evaluation_result FOR
        SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
END IF;


-- Datenbank bereinigen
--  drop table xyz_sample_function_output;
--  drop table xyz_sample_function_output;
FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    ELSIF v_object_type = 'VIEW' THEN
        function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
    END IF;
END LOOP;

--  drop userfunction
function_result := delete_function(identifier_key||'_'||func_name, message);
--  drop samplefunction
function_result := delete_function(identifier_key||'_SAMPLE_'||func_name, message);

-- return result
RETURN evaluation_result;

EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Funktion konnte nicht evaluiert werden! ('||sqlerrm||')');
END evaluate_question;

PROCEDURE insert_into_output_table
      ( identifier IN VARCHAR2, text IN VARCHAR2 ) AS
stmt VARCHAR2(1024);
BEGIN
  stmt:=REPLACE('INSERT INTO OUTPUT_TABLE (COLUMN_VALUE) VALUES(:1)', 'OUTPUT_TABLE', UPPER('OUTPUT_TABLE_'||identifier));
  EXECUTE IMMEDIATE stmt USING text;
END insert_into_output_table;

FUNCTION get_calls
  ( question_id IN NUMBER )
  RETURN  sys_refcursor AS
  select_result sys_refcursor;
BEGIN
  OPEN select_result FOR
    SELECT CALL
        FROM FUNC_CALLS
        WHERE QUESTIONID = question_id
        ORDER BY EXECORDER ASC;

  RETURN select_result;
END get_calls;

END edb_plsql_func_app;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_PROC_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PLSQLTRAINER"."EDB_PLSQL_PROC_APP" IS

  FUNCTION create_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
    command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
    EXECUTE IMMEDIATE command;
    EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
  END create_table;

  FUNCTION delete_table
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    RETURN 1;
    -- raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! ('||sqlerrm||')');
  END delete_table;

  FUNCTION create_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
    command VARCHAR2(2048);
  BEGIN
    command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
    EXECUTE IMMEDIATE command;
    COMMIT;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
  END create_view;

  FUNCTION delete_view
        ( table_name IN varchar2, identifier_key IN varchar2 )
    RETURN NUMBER AS
  BEGIN
    EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
    RETURN 1;
  EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! (' || sqlerrm || ')');
  END delete_view;

  FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

    RETURN select_result;
  END get_table_colum_names;

  FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
      'SELECT * FROM ' || v_table_name;

    RETURN select_result;
  END get_table_data;

  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
  BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
                                  ,l_num_cols
                                  ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
        LOOP
                CASE
                        WHEN l_descr_tab(i).col_type IN (2
                                         ,8) THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"number"},';
                        WHEN l_descr_tab(i).col_type = 12 THEN
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"date"},';
                        ELSE
                                l_row_data := '{"name":"' || l_descr_tab(i)
                                             .col_name || '","type":"text"},';
                END CASE;
                dbms_lob.writeappend(l_header_clob
                                    ,length(l_row_data)
                                    ,l_row_data);
        END LOOP;
        l_header_clob := rtrim(l_header_clob
                              ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
                INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
                                   ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
                                          ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
                              ,'_x0020_'
                              ,' ');
        dbms_lob.writeappend(l_header_clob
                            ,length(l_ret_clob)
                            ,l_ret_clob);
        RETURN l_header_clob;
  EXCEPTION
        WHEN OTHERS THEN
                dbms_output.put_line(SQLERRM);
                dbms_output.put_line(dbms_utility.format_error_backtrace);
                RETURN NULL;
  END get_json_fnc;

FUNCTION get_questions
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
  BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                QUESTIONTYP ,
                NEEDEDTABLE ,
                TEXT ,
                TESTTABLE ,
                PROCNAME ,
                SAMPLEPROC  FROM PROC_QUESTIONS ORDER BY QUESTIONID ASC;

    RETURN select_result;
  END get_questions;

  FUNCTION get_question
  ( question_id IN NUMBER)
  RETURN  sys_refcursor AS
  select_result sys_refcursor;
  BEGIN
  OPEN select_result FOR
      SELECT  QUESTIONID ,
              QUESTIONTYP ,
              NEEDEDTABLE ,
              TEXT ,
              TESTTABLE ,
              PROCNAME ,
              SAMPLEPROC  FROM PROC_QUESTIONS WHERE QUESTIONID = question_id;

  RETURN select_result;
END get_question;

FUNCTION create_procedure
      ( function IN VARCHAR2, msg OUT VARCHAR )
  RETURN NUMBER AS
  error VARCHAR2(4000 BYTE);
  proc VARCHAR2(1024);
  stmt VARCHAR2(1024);
BEGIN
  proc := REGEXP_SUBSTR(function, 'PROCEDURE\s*(\w*)', 1, 1, NULL, 1);
  EXECUTE IMMEDIATE function;
  msg:= 'Erfolgreich: Die Prozedur wurde ohne Fehler kompiliert!';
  RETURN 1;
EXCEPTION WHEN OTHERS THEN
  stmt := 'SELECT ''Zeile '' || line || '', Spalte '' || position || '' - '' || text FROM USER_ERRORS WHERE NAME = :funcname FETCH FIRST 1 ROWS ONLY';
  EXECUTE IMMEDIATE stmt INTO error USING proc;
  msg := 'Fehler: Die Funktion konnte nicht kompiliert werden! (' || sqlerrm || ') - Details: ' || error || ')';
  EXECUTE IMMEDIATE 'DROP PROCEDURE ' || proc;
  RETURN -1;
END create_procedure;

FUNCTION delete_procedure
      ( function_name IN VARCHAR2, msg OUT VARCHAR )
  RETURN NUMBER AS
BEGIN
  EXECUTE IMMEDIATE 'DROP PROCEDURE '||function_name;
  msg:= 'Erfolgreich: Die Prozedur wurde ohne Fehler gel�scht!';
  RETURN 1;
EXCEPTION WHEN OTHERS THEN
  msg := 'Fehler: Die Prozedur konnte nicht gel�scht werden! (' || sqlerrm || ')';
  RETURN -1;
END delete_procedure;

FUNCTION evaluate_question
    ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2)
  RETURN sys_refcursor AS
  evaluation_result sys_refcursor;
  user_result VARCHAR(4000 BYTE);
  mod_user_function VARCHAR(1024);
  sample_function VARCHAR(1024);
  mod_sample_function VARCHAR(1024);
  table_name VARCHAR(128);
  func_name VARCHAR(128);
  l_needed_table VARCHAR(128);
  l_tablen  BINARY_INTEGER;
  l_tab DBMS_UTILITY.uncl_array;
  function_result NUMBER;
  eval_result VARCHAR2(1024);
  message VARCHAR2(10000 BYTE);
  v_object_type VARCHAR2(32);
  v_func_call VARCHAR2(500);
  v_func_call_user VARCHAR2(500);
  v_func_call_sample VARCHAR2(500);
  result_difference NUMBER;
  resultnumber NUMBER;
  resulttesttable CLOB;
  resultreferencetable CLOB;
  sql_stmt VARCHAR2(512);
CURSOR func_call_cursor IS
        SELECT CALL
        FROM PROC_CALLS
        WHERE QUESTIONID = question_id
    ORDER BY EXECORDER ASC;
BEGIN

-- select samplefunction (solution) from FUNCTIONQUESTION
SELECT SAMPLEPROC, UPPER(TESTTABLE), PROCNAME, NEEDEDTABLE INTO sample_function, table_name, func_name, l_needed_table
  FROM PROC_QUESTIONS WHERE QUESTIONID = question_id;

-- mit komma getrennte liste (l_needed_table) wird hier geparst
DBMS_UTILITY.comma_to_table (
list   => l_needed_table,
tablen => l_tablen,
tab    => l_tab);

FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    END IF;
END LOOP;

-- erstellen der needed tables (identifier_key wird an tabellennamen angehangen)
FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := create_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    ELSIF v_object_type = 'VIEW' THEN
        function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
    END IF;
END LOOP;

-- �bergebene userfunktion muss vorbereitet werden -> mod_user_function
    mod_user_function := user_function;

    -- needed_tables mit identifier_key erweitern
    FOR i IN 1 .. l_tablen LOOP
        mod_user_function := REPLACE(UPPER(mod_user_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
    END LOOP;
    --   dbms_output durch eigenen Funktionsaufruf ersetzen
    -- mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_'||identifier_key||' VALUES');
    mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_proc_app.insert_into_output_table('''||identifier_key||''', ' );
    --     DBMS_OUTPUT.PUT_LINE('buffer is: '||buffer);
    -- insert_into_output_table('abcd', 'buffer is: '||buffer);

    -- userfunction mit identifier_key erweitern und kompilieren
    function_result := create_procedure(REPLACE(UPPER(mod_user_function),'PROCEDURE ','PROCEDURE '||UPPER(identifier_key)||'_'),message);
    -- return on compilation error
    IF function_result = -1 THEN
        OPEN evaluation_result FOR
            Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        RETURN evaluation_result;
    END IF;


    -- samplefunction mit identifier_key erweitern
    -- dbms_output durch inserts ersetzen
    mod_sample_function := sample_function;

    FOR i IN 1 .. l_tablen LOOP
        mod_sample_function := REPLACE(UPPER(mod_sample_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_SAMPLE_'||identifier_key));
    END LOOP;
    -- mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_SAMPLE_'||identifier_key||' VALUES');
    mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_proc_app.insert_into_output_table(''SAMPLE_'||identifier_key||''', ' );
    -- insert_into_output_table('SAMPLE_abcd', 'buffer is: '||buffer);

    -- samplefunction kompilieren
    function_result := create_procedure(REPLACE(UPPER(mod_sample_function),'PROCEDURE ','PROCEDURE '||UPPER(identifier_key)||'_SAMPLE_'),message);
    -- return on error (should never happen)
    IF function_result = -1 THEN
        OPEN evaluation_result FOR
            Select -3 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        RETURN evaluation_result;
    END IF;




-- hier m�ssten firingstatements auf beide funktion losgelassen werden
-- example in firingstatements steht:
 --- eur_to_usd(15);
 -- dann wird daraus IDKEY_eur_to_usd(15) und IDKEY_SAMPLE_eur_to_usd(15)

-- get the function calls from the table
--SELECT CALL INTO v_func_call FROM PROC_CALLS WHERE QUESTIONID = question_id ORDER BY EXECORDER ASC;

OPEN func_call_cursor;
	  LOOP
		  FETCH func_call_cursor INTO v_func_call;
		  EXIT WHEN func_call_cursor%NOTFOUND;
            v_func_call_user := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_'||UPPER(func_name));
            v_func_call_sample := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_SAMPLE_'||UPPER(func_name));

        -- execute function save result in function_result - save return value in output table
		  -- EXECUTE IMMEDIATE v_func_call_user INTO function_result;

          execute immediate 'begin ' ||v_func_call_user|| '; end;';

          execute immediate 'begin ' ||v_func_call_sample|| '; end;';



	  END LOOP;
	  CLOSE func_call_cursor;

-- ergebnisse vergleichen
-- table_name ist in den meisten f�llen (dbms_output) OUTPUT_TABLE

sql_stmt := UPPER(' select count(*) from(
                    (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_SAMPLE_' || identifier_key || ')
                    UNION ALL
                    (select * from ' || table_name || '_SAMPLE_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || ')
                    )');

EXECUTE IMMEDIATE sql_stmt INTO result_difference;

IF result_difference = 0 THEN
        message := 'Die Funktion hat das gew�nschte Ergebnis zur�ckgeliefert!';
        resultnumber := 1;

        OPEN evaluation_result FOR
            SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
ELSE
    SELECT get_json_fnc('edb_plsql_proc_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
    SELECT get_json_fnc('edb_plsql_proc_app.get_table_data(''' || table_name || '_SAMPLE_' || identifier_key || ''')') INTO resultreferencetable FROM DUAL;

    message := 'Die Funktion hat das falsche Ergebnis zur�ckgeliefert!';
    resultnumber := -1;

    OPEN evaluation_result FOR
        SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
END IF;


-- Datenbank bereinigen
--  drop table xyz_sample_function_output;
--  drop table xyz_sample_function_output;
FOR i IN 1 .. l_tablen LOOP
    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
    IF v_object_type = 'TABLE' THEN
        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
        function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
    ELSIF v_object_type = 'VIEW' THEN
        function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
    END IF;
END LOOP;

--  drop userfunction
function_result := delete_procedure(identifier_key||'_'||func_name, message);
--  drop samplefunction
function_result := delete_procedure(identifier_key||'_SAMPLE_'||func_name, message);

-- return result
RETURN evaluation_result;

EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Funktion konnte nicht evaluiert werden! ('||sqlerrm||')');
END evaluate_question;

PROCEDURE insert_into_output_table
      ( identifier IN VARCHAR2, text IN VARCHAR2 ) AS
stmt VARCHAR2(1024);
BEGIN
  stmt:=REPLACE('INSERT INTO OUTPUT_TABLE (COLUMN_VALUE) VALUES(:1)', 'OUTPUT_TABLE', UPPER('OUTPUT_TABLE_'||identifier));
  EXECUTE IMMEDIATE stmt USING text;
EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20108, 'Fehler: Konnte nicht in output_table schreiben! ('||sqlerrm||')');
END insert_into_output_table;

FUNCTION get_calls
  ( question_id IN NUMBER )
  RETURN  sys_refcursor AS
  select_result sys_refcursor;
BEGIN
  OPEN select_result FOR
    SELECT CALL
        FROM PROC_CALLS
        WHERE QUESTIONID = question_id
        ORDER BY EXECORDER ASC;

  RETURN select_result;
END get_calls;

END edb_plsql_proc_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PLSQLTRAINER"."EDB_PLSQL_APP" AUTHID CURRENT_USER IS
  FUNCTION evaluate_question ( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
  FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_table_if_exists ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION create_trigger( trigger IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
  FUNCTION fire_trigger ( question_id IN NUMBER, l_needed_table IN varchar2, identifier_key IN VARCHAR2 ) RETURN NUMBER;
  FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
  FUNCTION get_questions RETURN sys_refcursor;
  FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_firing_statements ( question_id IN NUMBER ) RETURN  sys_refcursor;
  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
END edb_plsql_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_FUNC_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PLSQLTRAINER"."EDB_PLSQL_FUNC_APP" AUTHID CURRENT_USER IS
  FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
  FUNCTION get_questions RETURN  sys_refcursor;
  FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
  FUNCTION create_function ( function IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
  FUNCTION evaluate_question ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
  FUNCTION delete_function ( function_name IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
  PROCEDURE insert_into_output_table ( identifier IN VARCHAR2, text IN VARCHAR2 );
  FUNCTION get_calls ( question_id IN NUMBER ) RETURN  sys_refcursor;
END edb_plsql_func_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_PROC_APP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "PLSQLTRAINER"."EDB_PLSQL_PROC_APP" AUTHID CURRENT_USER IS
  FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
  FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
  FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
  FUNCTION get_questions RETURN  sys_refcursor;
  FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
  FUNCTION create_procedure ( function IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
  FUNCTION evaluate_question ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
  FUNCTION delete_procedure ( function_name IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
  PROCEDURE insert_into_output_table ( identifier IN VARCHAR2, text IN VARCHAR2 );
  FUNCTION get_calls ( question_id IN NUMBER ) RETURN  sys_refcursor;
END edb_plsql_proc_app;

/
--------------------------------------------------------
--  DDL for Function CHECK_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."CHECK_TRIGGER"
    ( question_id IN NUMBER, message OUT VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
		SELECT FIRINGCODE
		FROM FIRINGSTATEMENTS
		WHERE QUESTIONID = question_id;
BEGIN
    OPEN test_statement_cursor;
	LOOP
		FETCH test_statement_cursor INTO test_statement;
		EXIT WHEN test_statement_cursor%NOTFOUND;
		EXECUTE IMMEDIATE test_statement;
	END LOOP;
	CLOSE test_statement_cursor;
    message := 'Erfolgreich: Der Trigger wurde ohne Fehler ausgef�hrt';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    message := 'Fehler: Bei der Ausf�hrung des Triggers ist ein Fehler aufgetreten! ('||sqlerrm||')';
    RETURN -1;
END;

/
--------------------------------------------------------
--  DDL for Function CREATE_DDL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."CREATE_DDL" (eingabe IN varchar2, loesung IN varchar2, eingabe_drop in VARCHAR2, loesung_drop in VARCHAR2 )
    RETURN sys_refcursor IS
    c NUMBER;
    code NUMBER;
    message  varchar2(50 char);
    v_result sys_refcursor;

 BEGIN
      execute IMMEDIATE eingabe;
      code := SQLCODE;
      message := SQLERRM;

      select count(ora_error_id)INTO c from ora_error where ora_error_id = code;

      IF c = 0 THEN
        INSERT INTO ORA_ERROR (ora_error_id, error_text) VALUES (code, message);
        commit;
      END IF;

      OPEN v_result for
        SELECT * FROM ora_error WHERE ora_error_id = code;

      EXECUTE IMMEDIATE eingabe_drop;

      RETURN v_result;

      EXCEPTION
        WHEN OTHERS THEN
          code := SQLCODE;
          message := SQLERRM;
          --EXECUTE IMMEDIATE tabelle;

          select count(ora_error_id)INTO c from ora_error where ora_error_id = code;

          IF c = 0 THEN
            INSERT INTO ORA_ERROR (ora_error_id, error_text) VALUES (code, message);
            COMMIT;
          END IF;

          OPEN v_result FOR
            SELECT * FROM ora_error WHERE ora_error_id = code;

          RETURN v_result;

END create_ddl;






/
--------------------------------------------------------
--  DDL for Function CREATE_TABLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."CREATE_TABLE"
        ( tablename IN varchar2, identifierKey IN varchar2 )
    return NUMBER AUTHID CURRENT_USER AS
    command VARCHAR2(2048);
BEGIN
    SELECT dbms_metadata.get_ddl('TABLE', tablename) INTO command FROM dual;
    command := REPLACE(REPLACE(REPLACE(REPLACE(command,tablename,tablename||'_'||identifierKey),'CONSTRAINT "','CONSTRAINT "'||identifierKey||'_'),'"',''),';','');
    EXECUTE IMMEDIATE command;
    EXECUTE IMMEDIATE 'INSERT INTO '||tablename||'_'||identifierKey||' SELECT * FROM '||tablename;
    COMMIT;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht angelegt werden! ('||sqlerrm||')');
END;

/
--------------------------------------------------------
--  DDL for Function CREATE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."CREATE_TRIGGER"
        ( trigger IN VARCHAR2, msg OUT VARCHAR )
    RETURN INT  AUTHID CURRENT_USER AS
BEGIN
    EXECUTE IMMEDIATE trigger;

    msg:= 'Erfolgreich: Der Trigger wurde ohne Fehler kompiliert!';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
  msg := 'Fehler: ' || sqlerrm;
  RETURN -1;
END;

/
--------------------------------------------------------
--  DDL for Function DELETE_TABLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."DELETE_TABLE"
        ( tablename IN varchar2, identifierKey IN varchar2)
    RETURN NUMBER AUTHID CURRENT_USER as
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE '||tablename||'_'||identifierKey;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gel�scht werden! ('||sqlerrm||')');
END;

/
--------------------------------------------------------
--  DDL for Function FIRE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."FIRE_TRIGGER"
    ( question_id IN NUMBER, table_name IN varchar2, identifier_key IN VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
		SELECT FIRINGCODE
		FROM FIRINGSTATEMENTS
		WHERE QUESTIONID = question_id
        ORDER BY EXECORDER ASC;
BEGIN
    OPEN test_statement_cursor;
	LOOP
		FETCH test_statement_cursor INTO test_statement;
		EXIT WHEN test_statement_cursor%NOTFOUND;
		EXECUTE IMMEDIATE REPLACE(UPPER(test_statement),UPPER(table_name),UPPER(table_name || '_' || identifier_key));
	END LOOP;
	CLOSE test_statement_cursor;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    RETURN 1;
END;

/
--------------------------------------------------------
--  DDL for Function GET_QUESTION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."GET_QUESTION"
    ( question_id IN NUMBER)
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                TEXT ,
                TESTTABLE ,
                TRIGGERNAME ,
                SAMPLETRIGGER  FROM QUESTIONS WHERE QUESTIONID = question_id;

    RETURN select_result;
END;

/
--------------------------------------------------------
--  DDL for Function PROOF_QUESTION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."PROOF_QUESTION"
        ( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2, message OUT VARCHAR2)
    RETURN INT AUTHID CURRENT_USER AS
    sample_trigger VARCHAR(1024);
    table_name VARCHAR(128);
    function_result NUMBER;
    result_diffrence NUMBER;
BEGIN
    SELECT SAMPLETRIGGER, UPPER(TESTTABLE) INTO sample_trigger, table_name FROM QUESTIONS WHERE QUESTIONID = question_id;

    function_result := create_table(table_name,identifier_key);

    function_result := create_trigger(REPLACE(REPLACE(UPPER(test_trigger),UPPER(table_name),UPPER(table_name||'_'||identifier_key)),'TRIGGER ','TRIGGER '||identifier_key|| '_'),message);
    IF function_result = -1 THEN
        function_result := delete_table(table_name,identifier_key);
        RETURN -1;
    END IF;

    function_result := fire_trigger(question_id,table_name,identifier_key);

    ---------------------------------------------------------------------
    function_result := create_table(table_name,identifier_key || '_res');

    function_result := create_trigger(REPLACE(REPLACE(UPPER(sample_trigger),UPPER(table_name),UPPER(table_name||'_'||identifier_key|| '_res')),'TRIGGER ','TRIGGER '||identifier_key|| '_res_'),message);
    IF function_result = -1 THEN
        function_result := delete_table(table_name,identifier_key || '_res');
        RETURN -1;
    END IF;

    function_result := fire_trigger(question_id,table_name,identifier_key || '_res');

    -----------------------------------------

    EXECUTE IMMEDIATE ' select count(*) from(
                        (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || '_res)
                        UNION ALL
                        (select * from ' || table_name || '_' || identifier_key || '_res MINUS select * from ' || table_name || '_' || identifier_key || '))' INTO result_diffrence;

    function_result := delete_table(table_name,identifier_key);
    function_result := delete_table(table_name,identifier_key || '_res');

    IF result_diffrence = 0 THEN
        message := 'Einwandfrei';
        RETURN 1;
    ELSE
        message := 'Fehler';
        RETURN 1;
    END IF;
END;

/
--------------------------------------------------------
--  DDL for Function TEST_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "PLSQLTRAINER"."TEST_TRIGGER"
    ( question_id IN NUMBER, message OUT VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
		SELECT FIRINGCODE
		FROM FIRINGSTATEMENTS
		WHERE QUESTIONID = question_id;
BEGIN
    OPEN test_statement_cursor;
	LOOP
		FETCH test_statement_cursor INTO test_statement;
		EXIT WHEN test_statement_cursor%NOTFOUND;
		EXECUTE IMMEDIATE test_statement;
	END LOOP;
	CLOSE test_statement_cursor;
    message := 'Erfolgreich: Der Trigger wurde ohne Fehler ausgef�hrt';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    message := 'Fehler: Bei der Ausf�hrung des Triggers ist ein Fehler aufgetreten! ('||sqlerrm||')';
    RETURN -1;
END;

/
--------------------------------------------------------
--  Constraints for Table ABTEILUNGEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ABTEILUNGEN" MODIFY ("ABT_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ABTEILUNGEN" MODIFY ("LEITER" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ABTEILUNGEN" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ABTEILUNGEN" ADD CONSTRAINT "ABT_PK" PRIMARY KEY ("ABT_NR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ARTIKEL
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ARTIKEL" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ARTIKEL" MODIFY ("BEZEICHNUNG" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ARTIKEL" MODIFY ("ARTIKEL_TYP" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ARTIKEL" ADD CONSTRAINT "AR_PK" PRIMARY KEY ("TNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table KUNDEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."KUNDEN" MODIFY ("KUN_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN" MODIFY ("NACHNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN" MODIFY ("VORNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN" ADD CONSTRAINT "KUN_PK" PRIMARY KEY ("KUN_NR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORA_ERROR
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ORA_ERROR" ADD PRIMARY KEY ("ORA_ERROR_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FUNC_CALLS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."FUNC_CALLS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_CALLS" MODIFY ("EXECORDER" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_CALLS" MODIFY ("CALL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table LIEFERPROGRAMME
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LIEFERPROGRAMME" MODIFY ("LIEF_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERPROGRAMME" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERPROGRAMME" ADD CONSTRAINT "LP_PK" PRIMARY KEY ("LIEF_NR", "TNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FUNC_QUESTIONS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" MODIFY ("FUNCTIONNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" MODIFY ("SAMPLEFUNCTION" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FUNC_QUESTIONS" ADD CONSTRAINT "FUNC_QUESTIONS_PK" PRIMARY KEY ("QUESTIONID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table GEHALTSPROTOKOLL
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."GEHALTSPROTOKOLL" MODIFY ("ANG_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."GEHALTSPROTOKOLL" MODIFY ("DATUM" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."GEHALTSPROTOKOLL" ADD CONSTRAINT "GE_PRO_PK" PRIMARY KEY ("ANG_NR", "DATUM")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LIEFERUNGEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("LIEFER_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("LIEF_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("LIEF_DATUM" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("MENGE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" MODIFY ("ZEITSTEMPEL" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" ADD CONSTRAINT "LG_PK" PRIMARY KEY ("LIEFER_NR", "LIEF_NR", "TNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FIRINGSTATEMENTS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS" MODIFY ("EXECORDER" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS" MODIFY ("FIRINGCODE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS" ADD CONSTRAINT "FIRINGSTATEMENTS_PK" PRIMARY KEY ("QUESTIONID", "EXECORDER")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LAGERBESTAND
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LAGERBESTAND" MODIFY ("LANR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LAGERBESTAND" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LAGERBESTAND" ADD CONSTRAINT "LAG_T_PK" PRIMARY KEY ("LANR", "TNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table QUESTIONS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" MODIFY ("TRIGGERNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" MODIFY ("SAMPLETRIGGER" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."QUESTIONS" ADD CONSTRAINT "QUESTIONS_PK" PRIMARY KEY ("QUESTIONID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LAGER
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LAGER" MODIFY ("LANR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LAGER" MODIFY ("BEZEICHNUNG" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LAGER" ADD CONSTRAINT "LAG_PK" PRIMARY KEY ("LANR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ANGESTELLTE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("ANG_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("ABT_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("AUFGABENBESCHREIBUNG" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("BERUF" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("NACHNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("VORNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" MODIFY ("GESCHLECHT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" ADD CONSTRAINT "ANG_PK" PRIMARY KEY ("ANG_NR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" ADD CONSTRAINT "GESCHLECHTX" CHECK ( Geschlecht IN ('w','W','m','M')) ENABLE;
--------------------------------------------------------
--  Constraints for Table TEILE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."TEILE" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."TEILE" ADD CONSTRAINT "TE_PK" PRIMARY KEY ("TNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "PLSQLTRAINER"."TEILE" ADD CONSTRAINT "TYPX" CHECK ( Typ IN ('Artikel', 'Baugruppe', 'Material')) ENABLE;
--------------------------------------------------------
--  Constraints for Table WERKE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."WERKE" MODIFY ("WNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."WERKE" MODIFY ("ORT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."WERKE" MODIFY ("STRASSE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."WERKE" ADD CONSTRAINT "WE_PK" PRIMARY KEY ("WNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUFTRAEGE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" MODIFY ("AUFTRAGS_TYP" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" MODIFY ("KUN_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" MODIFY ("ZEITSTEMPEL" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" ADD CONSTRAINT "AU_PK" PRIMARY KEY ("AUFTRAGSNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" ADD CONSTRAINT "AUFTRAGS_TYPX" CHECK (Auftrags_Typ IN ('Angebot', 'Anfrage', 'Auftrag')) ENABLE;
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" ADD CONSTRAINT "DATUMX" CHECK (Bestelldatum <= Lieferdatum) ENABLE;
--------------------------------------------------------
--  Constraints for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_PK" PRIMARY KEY ("TNR", "AUFTRAGSNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORTE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ORTE" MODIFY ("ORT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ORTE" MODIFY ("STRASSE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."ORTE" ADD CONSTRAINT "O_PK" PRIMARY KEY ("ORT", "STRASSE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table STRUKTUR
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" MODIFY ("OTEIL" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" MODIFY ("UTEIL" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" MODIFY ("POSITION" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" MODIFY ("MENGE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" ADD CONSTRAINT "S_PK" PRIMARY KEY ("OTEIL", "UTEIL", "POSITION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table GEH_KLASSEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."GEH_KLASSEN" MODIFY ("GEH_KLASSE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."GEH_KLASSEN" MODIFY ("MAX_GEHALT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."GEH_KLASSEN" MODIFY ("MIN_GEHALT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."GEH_KLASSEN" ADD CONSTRAINT "G_PK" PRIMARY KEY ("GEH_KLASSE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table POSITIONSARCHIV
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."POSITIONSARCHIV" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."POSITIONSARCHIV" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."POSITIONSARCHIV" ADD CONSTRAINT "PA_PK" PRIMARY KEY ("TNR", "AUFTRAGSNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PROC_QUESTIONS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."PROC_QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_QUESTIONS" MODIFY ("PROCNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_QUESTIONS" MODIFY ("SAMPLEPROC" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PROC_CALLS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."PROC_CALLS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_CALLS" MODIFY ("EXECORDER" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."PROC_CALLS" MODIFY ("CALL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TEILE_WERKE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."TEILE_WERKE" MODIFY ("TNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."TEILE_WERKE" MODIFY ("WNR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."TEILE_WERKE" ADD CONSTRAINT "T_WE_PK" PRIMARY KEY ("TNR", "WNR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LIEFERANTEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LIEFERANTEN" MODIFY ("LIEF_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERANTEN" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERANTEN" MODIFY ("ORT" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERANTEN" MODIFY ("STRASSE" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."LIEFERANTEN" ADD CONSTRAINT "LIEF_PK" PRIMARY KEY ("LIEF_NR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table KUNDEN_LEON
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."KUNDEN_LEON" MODIFY ("KUN_NR" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN_LEON" MODIFY ("NACHNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN_LEON" MODIFY ("VORNAME" NOT NULL ENABLE);
  ALTER TABLE "PLSQLTRAINER"."KUNDEN_LEON" ADD CONSTRAINT "LEON_KUN_PK" PRIMARY KEY ("KUN_NR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ANGESTELLTE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ANGESTELLTE" ADD CONSTRAINT "ANG_ABT_FK" FOREIGN KEY ("ABT_NR")
	  REFERENCES "PLSQLTRAINER"."ABTEILUNGEN" ("ABT_NR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ARTIKEL
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."ARTIKEL" ADD CONSTRAINT "AR_T_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AUFTRAEGE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" ADD CONSTRAINT "AU_KUN_FK" FOREIGN KEY ("KUN_NR")
	  REFERENCES "PLSQLTRAINER"."KUNDEN" ("KUN_NR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."AUFTRAEGE" ADD CONSTRAINT "AU_ANG_FK" FOREIGN KEY ("ANG_NR")
	  REFERENCES "PLSQLTRAINER"."ANGESTELLTE" ("ANG_NR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_AR_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."ARTIKEL" ("TNR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_AU_FK" FOREIGN KEY ("AUFTRAGSNR")
	  REFERENCES "PLSQLTRAINER"."AUFTRAEGE" ("AUFTRAGSNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FIRINGSTATEMENTS
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."FIRINGSTATEMENTS" ADD CONSTRAINT "FISTAT_QUEST" FOREIGN KEY ("QUESTIONID")
	  REFERENCES "PLSQLTRAINER"."QUESTIONS" ("QUESTIONID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LAGERBESTAND
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LAGERBESTAND" ADD CONSTRAINT "LAG_T_LAG_FK" FOREIGN KEY ("LANR")
	  REFERENCES "PLSQLTRAINER"."LAGER" ("LANR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."LAGERBESTAND" ADD CONSTRAINT "LAG_T_T_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LIEFERPROGRAMME
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LIEFERPROGRAMME" ADD CONSTRAINT "LP_LIEF_FK" FOREIGN KEY ("LIEF_NR")
	  REFERENCES "PLSQLTRAINER"."LIEFERANTEN" ("LIEF_NR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."LIEFERPROGRAMME" ADD CONSTRAINT "LP_T_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LIEFERUNGEN
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" ADD CONSTRAINT "LG_LIEF_FK" FOREIGN KEY ("LIEF_NR")
	  REFERENCES "PLSQLTRAINER"."LIEFERANTEN" ("LIEF_NR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."LIEFERUNGEN" ADD CONSTRAINT "LG_T_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table STRUKTUR
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" ADD CONSTRAINT "S_T_FK2" FOREIGN KEY ("UTEIL")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."STRUKTUR" ADD CONSTRAINT "S_T_FK" FOREIGN KEY ("OTEIL")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TEILE_WERKE
--------------------------------------------------------

  ALTER TABLE "PLSQLTRAINER"."TEILE_WERKE" ADD CONSTRAINT "T_WE_T_FK" FOREIGN KEY ("TNR")
	  REFERENCES "PLSQLTRAINER"."TEILE" ("TNR") ENABLE;
  ALTER TABLE "PLSQLTRAINER"."TEILE_WERKE" ADD CONSTRAINT "T_WE_WE_FK" FOREIGN KEY ("WNR")
	  REFERENCES "PLSQLTRAINER"."WERKE" ("WNR") ENABLE;
