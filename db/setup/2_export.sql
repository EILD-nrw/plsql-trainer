--------------------------------------------------------
--  Datei erstellt -Montag-Mai-10-2021
--------------------------------------------------------
--------------------------------------------------------
--  DDL for View RECHNUNGEN
--------------------------------------------------------

CREATE OR REPLACE FORCE EDITIONABLE VIEW "RECHNUNGEN" ("AUFTRAGSNR", "RECHNUNGSDATUM", "KUN_NR", "NACHNAME", "VORNAME", "ORT", "STRASSE", "PLZ", "TNR", "MENGE", "BEZEICHNUNG") AS
SELECT
    Auftraege.Auftragsnr, Auftraege.Rechnungsdatum,
    Kunden.Kun_nr, Kunden.Nachname,
    Kunden.Vorname, Kunden.Ort,
    Kunden.Strasse,Orte.Plz,
    Auftragspositionen.TNr,	Auftragspositionen.Menge,
    Artikel.Bezeichnung
FROM Kunden, Auftraege, Auftragspositionen, Orte, Artikel
WHERE Kunden.Kun_Nr = Auftraege.Kun_Nr
  AND Auftragspositionen.AuftragsNr = Auftraege.AuftragsNr
  AND Kunden.Ort = Orte.Ort
  AND Kunden.Strasse = Orte.Strasse
  AND Artikel.TNR	= Auftragspositionen.TNr
ORDER BY Auftraege.Auftragsnr;
--------------------------------------------------------
--  DDL for View RECHNUNGEN_INF845
--------------------------------------------------------

CREATE OR REPLACE FORCE EDITIONABLE VIEW "RECHNUNGEN_INF845" ("AUFTRAGSNR", "RECHNUNGSDATUM", "KUN_NR", "NACHNAME", "VORNAME", "ORT", "STRASSE", "PLZ", "TNR", "MENGE", "BEZEICHNUNG") AS
SELECT "AUFTRAGSNR","RECHNUNGSDATUM","KUN_NR","NACHNAME","VORNAME","ORT","STRASSE","PLZ","TNR","MENGE","BEZEICHNUNG" FROM RECHNUNGEN;
--------------------------------------------------------
--  DDL for Table ABTEILUNGEN
--------------------------------------------------------

CREATE TABLE "ABTEILUNGEN"
(	"ABT_NR" NUMBER(38,0),
     "LEITER" NUMBER(38,0),
     "NAME" VARCHAR2(50 BYTE),
     "ORT" VARCHAR2(50 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANGESTELLTE
--------------------------------------------------------

CREATE TABLE "ANGESTELLTE"
(	"ANG_NR" NUMBER(38,0),
     "ABT_NR" NUMBER(38,0),
     "AUFGABENBESCHREIBUNG" VARCHAR2(50 BYTE),
     "BERUF" VARCHAR2(50 BYTE),
     "NACHNAME" VARCHAR2(50 BYTE),
     "VORNAME" VARCHAR2(50 BYTE),
     "GESCHLECHT" CHAR(1 BYTE),
     "EINTRITTSDATUM" DATE,
     "GEHALT" NUMBER(9,2) DEFAULT 0,
     "ABZUEGE" NUMBER(9,2) DEFAULT 0,
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE),
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ARTIKEL
--------------------------------------------------------

CREATE TABLE "ARTIKEL"
(	"TNR" NUMBER(38,0),
     "BEZEICHNUNG" VARCHAR2(50 BYTE),
     "ARTIKEL_TYP" VARCHAR2(50 BYTE),
     "VERKAUFSPREIS" NUMBER,
     "JAHRESUMSATZ" NUMBER,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table AUFTRAEGE
--------------------------------------------------------

CREATE TABLE "AUFTRAEGE"
(	"AUFTRAGSNR" NUMBER(38,0),
     "AUFTRAGS_TYP" VARCHAR2(50 BYTE),
     "KUN_NR" NUMBER(38,0),
     "ANG_NR" NUMBER(38,0),
     "BEREITS_GEZAHLT" NUMBER,
     "BESTELLDATUM" DATE,
     "LIEFERDATUM" DATE,
     "RECHNUNGSDATUM" DATE,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

CREATE TABLE "AUFTRAGSPOSITIONEN"
(	"TNR" NUMBER(38,0),
     "AUFTRAGSNR" NUMBER(38,0),
     "MENGE" NUMBER
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FIRINGSTATEMENTS
--------------------------------------------------------

CREATE TABLE "FIRINGSTATEMENTS"
(	"QUESTIONID" NUMBER,
     "EXECORDER" NUMBER,
     "FIRINGCODE" VARCHAR2(500 CHAR)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FUNC_CALLS
--------------------------------------------------------

CREATE TABLE "FUNC_CALLS"
(	"QUESTIONID" NUMBER,
     "EXECORDER" NUMBER,
     "CALL" VARCHAR2(500 CHAR)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FUNC_QUESTIONS
--------------------------------------------------------

CREATE TABLE "FUNC_QUESTIONS"
(	"QUESTIONID" NUMBER,
     "TEXT" VARCHAR2(1000 CHAR),
     "TESTTABLE" VARCHAR2(20 CHAR),
     "FUNCTIONNAME" VARCHAR2(20 CHAR),
     "SAMPLEFUNCTION" VARCHAR2(1000 CHAR),
     "QUESTIONTYP" VARCHAR2(64 BYTE),
     "NEEDEDTABLE" VARCHAR2(128 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table GEHALTSPROTOKOLL
--------------------------------------------------------

CREATE TABLE "GEHALTSPROTOKOLL"
(	"ANG_NR" NUMBER(38,0),
     "ALT_GEHALT" NUMBER(9,2) DEFAULT 0,
     "NEU_GEHALT" NUMBER(9,2) DEFAULT 0,
     "DATUM" DATE
) SEGMENT CREATION DEFERRED
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table GEH_KLASSEN
--------------------------------------------------------

CREATE TABLE "GEH_KLASSEN"
(	"GEH_KLASSE" NUMBER(38,0),
     "MAX_GEHALT" NUMBER,
     "MIN_GEHALT" NUMBER
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table KUNDEN
--------------------------------------------------------

CREATE TABLE "KUNDEN"
(	"KUN_NR" NUMBER(38,0),
     "NACHNAME" VARCHAR2(50 BYTE),
     "VORNAME" VARCHAR2(50 BYTE),
     "GESCHLECHT" VARCHAR2(1 BYTE),
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE),
     "TELEFONNR" VARCHAR2(50 BYTE),
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table KUNDEN_LEON
--------------------------------------------------------

CREATE TABLE "KUNDEN_LEON"
(	"KUN_NR" NUMBER(38,0),
     "NACHNAME" VARCHAR2(50 BYTE),
     "VORNAME" VARCHAR2(50 BYTE),
     "GESCHLECHT" VARCHAR2(1 BYTE),
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE),
     "TELEFONNR" VARCHAR2(50 BYTE),
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LAGER
--------------------------------------------------------

CREATE TABLE "LAGER"
(	"LANR" NUMBER(38,0),
     "BEZEICHNUNG" VARCHAR2(50 BYTE),
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LAGERBESTAND
--------------------------------------------------------

CREATE TABLE "LAGERBESTAND"
(	"LANR" NUMBER(38,0),
     "TNR" NUMBER(38,0),
     "BESTAND" NUMBER,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERANTEN
--------------------------------------------------------

CREATE TABLE "LIEFERANTEN"
(	"LIEF_NR" NUMBER(38,0),
     "NAME" VARCHAR2(50 BYTE),
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE),
     "TELEFONNR" VARCHAR2(50 BYTE),
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERPROGRAMME
--------------------------------------------------------

CREATE TABLE "LIEFERPROGRAMME"
(	"LIEF_NR" NUMBER(38,0),
     "TNR" NUMBER(38,0),
     "BESTELLNR" VARCHAR2(20 BYTE),
     "EINKAUFSPREIS" NUMBER,
     "GESAMTMENGE" NUMBER,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table LIEFERUNGEN
--------------------------------------------------------

CREATE TABLE "LIEFERUNGEN"
(	"LIEFER_NR" NUMBER(38,0),
     "LIEF_NR" NUMBER(38,0),
     "TNR" NUMBER(38,0),
     "LIEF_DATUM" DATE,
     "MENGE" NUMBER DEFAULT 1,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ORA_ERROR
--------------------------------------------------------

CREATE TABLE "ORA_ERROR"
(	"ORA_ERROR_ID" NUMBER(10,0),
     "ERROR_HINT_ID" NUMBER(10,0),
     "COUNTER" NUMBER(10,0),
     "ERROR_TEXT" VARCHAR2(255 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ORTE
--------------------------------------------------------

CREATE TABLE "ORTE"
(	"ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE),
     "PLZ" NUMBER(38,0)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table OUTPUT_TABLE
--------------------------------------------------------

CREATE TABLE "OUTPUT_TABLE"
(	"COLUMN_VALUE" VARCHAR2(4000 BYTE)
) SEGMENT CREATION DEFERRED
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table POSITIONSARCHIV
--------------------------------------------------------

CREATE TABLE "POSITIONSARCHIV"
(	"TNR" NUMBER(38,0),
     "AUFTRAGSNR" NUMBER(38,0),
     "MENGE" NUMBER
) SEGMENT CREATION DEFERRED
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table PROC_CALLS
--------------------------------------------------------

CREATE TABLE "PROC_CALLS"
(	"QUESTIONID" NUMBER,
     "EXECORDER" NUMBER,
     "CALL" VARCHAR2(500 CHAR)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table PROC_QUESTIONS
--------------------------------------------------------

CREATE TABLE "PROC_QUESTIONS"
(	"QUESTIONID" NUMBER,
     "TEXT" VARCHAR2(500 CHAR),
     "TESTTABLE" VARCHAR2(20 CHAR),
     "PROCNAME" VARCHAR2(20 CHAR),
     "SAMPLEPROC" VARCHAR2(1000 CHAR),
     "QUESTIONTYP" VARCHAR2(64 BYTE),
     "NEEDEDTABLE" VARCHAR2(128 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table QUESTIONS
--------------------------------------------------------

CREATE TABLE "QUESTIONS"
(	"QUESTIONID" NUMBER,
     "TEXT" VARCHAR2(500 CHAR),
     "TESTTABLE" VARCHAR2(20 CHAR),
     "TRIGGERNAME" VARCHAR2(20 CHAR),
     "SAMPLETRIGGER" VARCHAR2(1000 CHAR),
     "QUESTIONTYP" VARCHAR2(64 BYTE),
     "NEEDEDTABLE" VARCHAR2(128 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table STRUKTUR
--------------------------------------------------------

CREATE TABLE "STRUKTUR"
(	"OTEIL" NUMBER(38,0),
     "UTEIL" NUMBER(38,0),
     "POSITION" NUMBER(38,0),
     "MENGE" NUMBER,
     "AUSSCHUSS" NUMBER,
     "ARBEITSGANG" NUMBER(38,0),
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEILE
--------------------------------------------------------

CREATE TABLE "TEILE"
(	"TNR" NUMBER(38,0),
     "ME" VARCHAR2(10 BYTE),
     "BEZEICHNUNG" VARCHAR2(50 BYTE),
     "TYP" VARCHAR2(50 BYTE),
     "HERSTELLKOSTEN" NUMBER,
     "EINKAUFSPREIS" NUMBER,
     "MINDESTBESTAND" NUMBER,
     "BESTAND" NUMBER,
     "LIEFERZEIT" NUMBER,
     "HERSTELLDAUER" NUMBER,
     "GEWICHT" NUMBER,
     "RESERVIERT" NUMBER,
     "VERFUEGBAR" NUMBER,
     "ZEITSTEMPEL" DATE
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TEILE_WERKE
--------------------------------------------------------

CREATE TABLE "TEILE_WERKE"
(	"TNR" NUMBER(38,0),
     "WNR" NUMBER(38,0)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table WERKE
--------------------------------------------------------

CREATE TABLE "WERKE"
(	"WNR" NUMBER(38,0),
     "BEZEICHNUNG" VARCHAR2(50 BYTE),
     "ORT" VARCHAR2(50 BYTE),
     "STRASSE" VARCHAR2(50 BYTE)
) SEGMENT CREATION IMMEDIATE
    PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255
    NOCOMPRESS LOGGING
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Sequence LIEFER_NR
--------------------------------------------------------

CREATE SEQUENCE  "LIEFER_NR"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 61 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
REM INSERTING into ABTEILUNGEN
SET DEFINE OFF;
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('1','1','GESCHÄFTSFÜHRUNG','Köln');
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('2','2','PRODUKTION','Lindlar');
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('3','3','VERTRIEB','Dortmund');
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('4','4','EINKAUF','Lindlar');
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('5','5','ARBEITSVORBEREITUNG','Lindlar');
Insert into ABTEILUNGEN (ABT_NR,LEITER,NAME,ORT) values ('6','6','DATENVERARBEITUNG','Köln');
REM INSERTING into ANGESTELLTE
SET DEFINE OFF;
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('1','1','Manchmal sind die Frauen Chef','Betriebswirt','Müller','Josefine','w',to_date('01.02.91','DD.MM.RR'),'10000','3400','Köln','Memelerstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('2','2','Fehlt noch','Mathematiker','Fama','Hans','m',to_date('07.05.91','DD.MM.RR'),'9000','2300','Gummersbach','Inselweg',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('3','3','Fehlt noch','Betriebswirt','Heck','Iris','w',to_date('06.07.88','DD.MM.RR'),'7500','3000','Gummersbach','Kaiserstr',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('4','4','Fehlt noch','Kaufmann','Schmidt','Otto','m',to_date('01.07.95','DD.MM.RR'),'6500','2000','Leverkusen','Netzestr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('5','5','Fehlt noch','Informatiker','Weber','Anna','w',to_date('01.06.95','DD.MM.RR'),'6600','2000','Leverkusen','Quarzstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('6','6','Fehlt noch','Informatiker','Frisch','Paul','m',to_date('01.06.99','DD.MM.RR'),'5000','2000','Bergisch Gladbach','Grubenfeld',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('7','6','Fehlt noch','Informatiker','Frisch','Paula','w',to_date('01.03.93','DD.MM.RR'),'5000','2100','Bergisch Gladbach','Grubenfeld',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('8','2','Fehlt noch','Informatiker','Weber','Anna','w',to_date('01.06.95','DD.MM.RR'),'3700','1500','Bergisch Gladbach','Burgstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('9','2','Fehlt noch','Ingenieur','Falser','Jonas','m',to_date('01.06.95','DD.MM.RR'),'3600','1500','Bergisch Gladbach','Burgstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('10','2','Fehlt noch','Schreibkraft','Wanne','Erna','w',to_date('01.06.95','DD.MM.RR'),'4000','10','Bergisch Gladbach','Erntestr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('11','2','Fehlt noch','Elektriker','Brunn','Ilse','w',to_date('01.01.95','DD.MM.RR'),'3600','1500','Bergisch Gladbach','Fichtenweg',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('12','3','Fehlt noch','Ingenieur','Brater','Willi','m',to_date('01.01.97','DD.MM.RR'),'4600','1500','Dortmund','Bedastr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('13','3','Fehlt noch','Ingenieur','Baer','Susanne','w',to_date('01.01.92','DD.MM.RR'),'4800','1500','Dortmund','Prellerstr.',null);
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('14','3','Fehlt noch','Schreibkraft','Bille','Max','m',to_date('01.01.93','DD.MM.RR'),'610','30','Dortmund','Plutostr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('15','4','Fehlt noch','Kaufmann','Wahn','Thorsten','m',to_date('01.01.94','DD.MM.RR'),'3610','1030','Gladbeck','Weserstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('16','4','Fehlt noch','Kaufmann','Wuton','Petra','w',to_date('01.01.94','DD.MM.RR'),'4610','1230','Gladbeck','Triebstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('17','5','Fehlt noch','Kaufmann','Glatt','Lucas','m',to_date('01.01.94','DD.MM.RR'),'5200','2230','Gladbeck','Alfredstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('18','5','Fehlt noch','Kaufmann','Gotte','Barbara','w',to_date('01.01.94','DD.MM.RR'),'5500','3230','Gladbeck','Saarlandstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('19','5','Fehlt noch','Kaufmann','Kall','Holger','m',to_date('01.01.94','DD.MM.RR'),'4500','3230','Gladbeck','Talstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('20','6','Fehlt noch','Informatiker','Käse','Franz','m',to_date('01.01.97','DD.MM.RR'),'4500','3230','Gladbeck','Talstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('21','6','Fehlt noch','Informatiker','Kussmann','Anna','w',to_date('01.01.97','DD.MM.RR'),'4500','3230','Gladbeck','Unterhof',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('22','6','Fehlt noch','Informatiker','Bold','Leo','m',to_date('01.01.97','DD.MM.RR'),'3500','3230','Gladbeck','Thomastr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('23','6','Fehlt noch','Informatiker','Butz','Max','m',to_date('01.01.98','DD.MM.RR'),'3500','3230','Gladbeck','Unterhof',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('24','2','Fehlt noch','Montieur','Schmidt','Hugo','m',to_date('01.01.98','DD.MM.RR'),'3500','3230','Gladbeck','Roonstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('25','2','Fehlt noch','Betriebswirt','Barthels','Isabel','w',to_date('01.01.95','DD.MM.RR'),'3500','3230','Gladbeck','Schildberg',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('26','2','Fehlt noch','Kaufmann','Schneider','Ernst','m',to_date('01.06.95','DD.MM.RR'),'4000','2000','Bergisch Gladbach','Falkenstr.',to_date('13.03.02','DD.MM.RR'));
Insert into ANGESTELLTE (ANG_NR,ABT_NR,AUFGABENBESCHREIBUNG,BERUF,NACHNAME,VORNAME,GESCHLECHT,EINTRITTSDATUM,GEHALT,ABZUEGE,ORT,STRASSE,ZEITSTEMPEL) values ('27','3','Fehlt noch','Schreibkraft','Budar','Hermann','m',to_date('01.01.96','DD.MM.RR'),'2800','1500','Dortmund','Planckstr.',null);
REM INSERTING into ARTIKEL
SET DEFINE OFF;
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('1','Rocky Mountain Element Race Typ 1','Mountainbike','3500','200',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('31','Herrenrad GT-LTS 18','Rennrad','3500','400',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('54','Klapprad Prompton P3','Klapprad','1600','180',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('55','CANNONDALE FSL','Mountainbike','3700','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('56','HERCULES NEPA','Trekkingrad','1700','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('57','Steppenwolf TAO','Mountainbike','1900','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('58','SWITCHBACK AGENT','Jugendrad','899','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('59','STEVENS R.P.R.2 RX100 8FACH','Rennmaschine','1800','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('60','Scott ATACAMA TOUR','Crossrad','2399','80',to_date('27.07.18','DD.MM.RR'));
Insert into ARTIKEL (TNR,BEZEICHNUNG,ARTIKEL_TYP,VERKAUFSPREIS,JAHRESUMSATZ,ZEITSTEMPEL) values ('61','ROTWILD RCC-03','Mountainbike','3499','80',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into AUFTRAEGE
SET DEFINE OFF;
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('1','Auftrag','1','3','0',to_date('27.07.18','DD.MM.RR'),to_date('26.08.18','DD.MM.RR'),to_date('25.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('2','Auftrag','2','12','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('3','Angebot','5','12','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('4','Auftrag','2','13','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('5','Angebot','3','27','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
Insert into AUFTRAEGE (AUFTRAGSNR,AUFTRAGS_TYP,KUN_NR,ANG_NR,BEREITS_GEZAHLT,BESTELLDATUM,LIEFERDATUM,RECHNUNGSDATUM,ZEITSTEMPEL) values ('6','Auftrag','2','3','0',to_date('27.07.18','DD.MM.RR'),to_date('16.08.18','DD.MM.RR'),to_date('05.09.18','DD.MM.RR'),to_date('27.07.18','DD.MM.RR'));
REM INSERTING into AUFTRAGSPOSITIONEN
SET DEFINE OFF;
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('1','1','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','1','2');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','2','2');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('60','2','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('57','2','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','3','10');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('55','3','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('58','4','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('58','5','18');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('56','5','1');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('57','5','12');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('1','6','120');
Insert into AUFTRAGSPOSITIONEN (TNR,AUFTRAGSNR,MENGE) values ('31','6','130');
REM INSERTING into FIRINGSTATEMENTS
SET DEFINE OFF;
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('1','1','INSERT INTO Angestellte VALUES (28, 3, ''Fehlt noch'', ''Schreibkraft'',
''Budar'', ''Hermann'', ''m'',  TO_Date( ''01/01/1996 12:00:00 AM'', ''MM/DD/YYYY HH:MI:SS AM'')
, 2800, 1500, ''Dortmund'', ''Planckstr.'', NULL)');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('2','1','update Abteilungen set Leiter=10 where Name=''Einkauf''');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('3','1','update Lagerbestand set bestand = 1000 where tnr=1 and lanr=2');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('4','1','update Auftraege set bereits_gezahlt=10500 where auftragsnr=1');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('5','1','update angestellte set gehalt=4100 where ang_nr=26');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('6','1','delete from Auftragspositionen where AuftragsNR=5');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('7','1','update Angestellte set Gehalt=5500 where Ang_Nr=7');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('8','2','update Angestellte set gehalt=9000 where ang_nr=1');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('9','2','update angestellte set ang_nr=30 where ang_nr=2');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('10','2','update Geh_klassen set max_gehalt=4500 where geh_klasse=4');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('8','1','update Angestellte set gehalt=8000 where ang_nr=3');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('2','2','update Abteilungen set Leiter=12 where Name=''Produktion''');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('4','2','update Auftraege set bereits_gezahlt=10000 where auftragsnr=2');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('5','2','update angestellte set gehalt=6000 where ang_nr=6');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('7','2','update Angestellte set Nachname=''Schmitz'' where Ang_Nr=8');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('9','1','update Angestellte set Nachname=''Schmitz'' where Ang_Nr=8');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('10','1','update Geh_klassen set max_gehalt=1500 where geh_klasse=5');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('11','1','UPDATE Rechnungen SET MENGE = 2 WHERE TNR = 1 AND AUFTRAGSNR = 1');
Insert into FIRINGSTATEMENTS (QUESTIONID,EXECORDER,FIRINGCODE) values ('12','1','INSERT INTO Rechnungen VALUES (1,TO_Date( ''02/01/0091 12:00:00 AM'', ''MM/DD/YYYY HH:MI:SS AM''),1,''Sonnenschein'',''Susi'',''Koeln'',''Testweg'',51709,60,22,''Test'')');
REM INSERTING into FUNC_CALLS
SET DEFINE OFF;
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','1','tage_im_jahr(1984)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','2','tage_im_jahr(2000)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','3','tage_im_jahr(2100)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','1','anrede_bestimmen(''M'',''Schmitz'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','2','anrede_bestimmen(''w'',''Meier'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','3','anrede_bestimmen('''','''')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','4','anrede_bestimmen(''M'','''')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','1','gehaltsklasse(7)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','2','gehaltsklasse(14)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','3','gehaltsklasse(2)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','1','stueckliste(60)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','2','stueckliste(62)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('7','3','stueckliste(2)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','1','zeichen_pruefen(''Daten:banken'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','2','zeichen_pruefen(''Datenbank:en'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','3','zeichen_pruefen(''D:aten:bank:en'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('8','4','zeichen_pruefen(''Datenbanken'')');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','1','eur_to_usd(15)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','2','eur_to_usd(99)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','1','taschenrechner(1,''+'',1)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','2','taschenrechner(4,''*'',8)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','3','taschenrechner(984,''/'',84)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','4','taschenrechner(99,''-'',101)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','1','schaltjahr_check(1984)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','2','schaltjahr_check(2000)');
Insert into FUNC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','3','schaltjahr_check(2100)');
REM INSERTING into FUNC_QUESTIONS
SET DEFINE OFF;
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('3','Schreiben Sie eine PL/SQL-Funktion mit dem Namen "tage_im_jahr", die zu einem gegebenen Jahr die Zahl der Tage zurückliefert. Schaltjahre mit 366 Tagen sind solche, die durch 400 teilbar sind und außerdem solche, die durch 4, aber nicht durch 100 teilbar sind. Alle anderen Jahre haben 365 Tage.

Hinweis: Benutzen Sie die Modulo-Funktion MOD(n,m), die den Rest beim Teilen von n durch m liefert.','output_table','tage_im_jahr','CREATE OR REPLACE Function tage_im_jahr (Jahr INTEGER)
RETURN INTEGER AS
test_400 INTEGER;
test_100 INTEGER;
test_4   INTEGER;
Ergebnis INTEGER;
BEGIN
  test_400 :=  MOD (Jahr, 400);
  test_100 :=  MOD (Jahr, 100);
  test_4   :=  MOD (Jahr, 4);
  IF test_400 = 0 OR (test_100 > 0 AND test_4 = 0)
  THEN
  Ergebnis := 366;
  ELSE
  Ergebnis := 365;
  END IF;
 RETURN Ergebnis;
END;','function','output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('5','Schreiben Sie eine Funktion mit dem Namen "anrede_bestimmen", der als Übergabeparameter ein Geschlecht und ein Nachname mitgegeben wird. Das Ergebnis soll wie folgt aussehen: "Sehr geehrte Frau Meier", bzw. "Sehr geehrter Herr Müller". Beim Geschlecht sind die zulässigen Werte "leer/NULL", "w" und "m", unabhängig von der Groß/Kleinschreibung, beim Nachnamen kann auch ein Nullwert übergeben werden. Wird kein Geschlecht oder kein Nachname übergeben (NULL), oder wird als Geschlecht ein ungültiger Wert übergeben, dann wird nur die Anrede "Sehr geehrte Damen und Herren" zurückgegeben, unabhängig von den Werten des anderen Parameters.','output_table','anrede_bestimmen','CREATE OR REPLACE FUNCTION anrede_bestimmen (
   p_geschlecht   IN VARCHAR2 DEFAULT NULL,
   p_nachname     IN VARCHAR2 DEFAULT NULL)
   RETURN VARCHAR2
IS
   v_anrede   VARCHAR2 (30) := ''Sehr geehrte'';
BEGIN
   IF p_geschlecht NOT IN (''W'', ''w'', ''M'', ''m'') OR p_nachname IS NULL
   THEN
      RETURN ''Sehr geehrte Damen und Herren'';
   END IF;
   IF p_geschlecht IN (''W'', ''w'')
   THEN
      v_anrede := v_anrede || '' Frau '';
   ELSIF p_geschlecht IN (''M'', ''m'')
   THEN
      v_anrede := v_anrede || ''r Herr '';
   END IF;
   RETURN v_anrede || p_nachname;
END;','function','output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('6','Schreiben Sie eine PL/SQL-Funktion "gehaltsklasse", die zu einem Angestellten die Gehaltsklasse ermittelt. Übergeben werden soll die Ang-Nr, ermittelt werden soll die Gehaltsklasse, d.h. die Geh_Klasse, so dass das Gehalt größer als das Min_Gehalt und kleiner oder gleich dem Max_Gehalt ist.','output_table','gehaltsklasse','CREATE OR REPLACE FUNCTION gehaltsklasse (
   p_ang_nr   IN NUMBER DEFAULT NULL)
   RETURN NUMBER
IS
   v_klasse   NUMBER DEFAULT 0;
BEGIN
   SELECT GEH_KLASSEN.GEH_KLASSE
     INTO v_klasse
     FROM angestellte, geh_klassen
    WHERE     angestellte.gehalt > GEH_KLASSEN.MIN_GEHALT
          AND angestellte.gehalt <= GEH_KLASSEN.MAX_GEHALT
          AND ANGESTELLTE.ANG_NR = p_ang_nr;
   RETURN v_klasse;
END;','function','angestellte,geh_klassen,output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('7','Schreiben Sie eine PL/SQL-Funktion "stueckliste", die zu einer Teile_Nr die Stücklistentiefe bestimmt, d.h. die Länge des maximalen Wegs in der Stückliste, die zu einem Blatt führt. Die Stücklisten werden in der Struktur-Tabelle verwaltet, d.h. z.B. die Beziehung des Teils mit der Nummer 60 zum Teil 2 wird in der Struktur-Tabelle in der Zeile mit dem OTEIL = 60 und dem UTEIL = 2 gespeichert. Die Tiefe ist in diesem Beispiel 3. Verwenden Sie dazu das CONNECT-BY-Statement von Oracle!','output_table','stueckliste','CREATE OR REPLACE FUNCTION stueckliste (
   p_oteil   IN NUMBER DEFAULT NULL)
   RETURN NUMBER
IS
   v_tiefe   NUMBER DEFAULT 0;
BEGIN
       SELECT MAX (LEVEL) into v_tiefe
         FROM Struktur
   START WITH OTeil = p_oteil
   CONNECT BY PRIOR UTeil = OTeil;

   RETURN v_tiefe;
END;','function','struktur,output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('8','Schreiben Sie eine PL/SQL-Funktion "zeichen_pruefen", die für einen übergebenen Text prüft, an welcher Stelle im Text ein Doppelpunkt enthalten ist! Der Rückgabewert soll vom Typ INTEGER sein und die Position enthalten, an der das gesuchte Zeichen, nämlich der Doppelpunkt, zum ersten Mal auftritt! Falls kein Doppelpunkt auftritt, soll der Wert 0 zurückgegeben werden.
Sie können die Oracle-Funktion INSTR nutzen
    • instr( string1, string2 [, start_position [,  nth_appearance ] ] )
        ? string1:   zu durchsuchender Text.,
        ? string2:	  Substring, der in string 1 gesucht wird.
        ? Start_position: ist optional
        ? nth_appearance  Wie oft der string 1 in string 2 auftritt, ist optional
Instr gibt 0 zurück, wenn der string2 nicht gefunden wird.','output_table','zeichen_pruefen','CREATE OR REPLACE FUNCTION zeichen_pruefen (text VARCHAR2)
   RETURN INTEGER
IS
zahl  integer :=  0;
BEGIN
   zahl :=  INSTR (text, '':'', 1,  1);
   RETURN zahl;
END;','function','output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('4','Schreiben Sie eine Taschenrechner-Funktion "taschenrechner", die die vier Grundrechenarten kann: Addition „+“, Subtraktion „-“, Division „/“, Multiplikation „*“!
Der Funktion werden drei Parameter übergeben, den ersten Operanden, das Symbol der Rechenoperation und den zweiten Operanden. Das berechnete Ergebnis ist der Rückgabewert.','output_table','taschenrechner','CREATE OR REPLACE FUNCTION taschenrechner (o1 IN NUMBER, operator   IN VARCHAR2, o2  IN NUMBER)
   RETURN NUMBER
IS
BEGIN
  IF   operator  = ''+'' THEN RETURN o1 + o2;
  ELSIF operator = ''-'' THEN RETURN o1 - o2;
  ELSIF operator = ''*'' THEN RETURN o1 * o2;
  ELSIF operator = ''/'' THEN RETURN o1 / o2;
  END IF;
END;','function','output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('1','Schreiben Sie eine PL/SQL-Funktion mit dem Namen "schaltjahr_check", die, wenn ein übergebenes Jahr ein Schaltjahr ist, den booleschen Wert TRUE zurückgibt und wenn nicht, den Wert FALSE. Schaltjahre mit 366 Tagen sind solche, die durch 400 teilbar sind und außerdem solche, die durch 4, aber nicht durch 100 teilbar sind. Alle anderen Jahre haben 365 Tage.

Hinweis: Benutzen Sie die Modulo-Funktion MOD(n,m), die den Rest beim Teilen von n durch m liefert.','output_table','schaltjahr_check','CREATE OR REPLACE FUNCTION schaltjahr_check (p_jahr INTEGER)
RETURN  VARCHAR2
AS
BEGIN
    IF      MOD(p_jahr, 400) = 0
       OR  (MOD(p_jahr, 100) <> 0 AND MOD(p_jahr, 4) = 0)
    THEN
       DBMS_OUTPUT.PUT_LINE(p_jahr||'' ist ein Schaltjahr!'');
       RETURN ''TRUE'';
    ELSE
       DBMS_OUTPUT.PUT_LINE(p_jahr||'' ist kein Schaltjahr!'');
       RETURN ''FALSE'';
    END IF;
END;','function','output_table');
Insert into FUNC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,FUNCTIONNAME,SAMPLEFUNCTION,QUESTIONTYP,NEEDEDTABLE) values ('2','Es soll eine Funktion "eur_to_usd" erstellt werden, der ein Wert in € übergeben wird und ihn umgerechnet in Dollar zurückgibt. Der Wechselkurs für diese Aufgabe ist 1.13 (1€ = 1,13$)','output_table','eur_to_usd','CREATE OR REPLACE FUNCTION eur_to_usd (euro NUMBER)
  RETURN NUMBER IS
  buffer NUMBER;
  BEGIN
    buffer := (euro * 1.13);
    RETURN buffer;
END;','function','output_table');
REM INSERTING into GEHALTSPROTOKOLL
SET DEFINE OFF;
REM INSERTING into GEH_KLASSEN
SET DEFINE OFF;
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('1','100000','8000');
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('2','7999','6000');
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('3','5999','4000');
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('4','3999','2000');
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('5','1999','620');
Insert into GEH_KLASSEN (GEH_KLASSE,MAX_GEHALT,MIN_GEHALT) values ('6','620','0');
REM INSERTING into KUNDEN
SET DEFINE OFF;
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','Tholler','Andreas','m','Köln','Belaweg','0221/956788',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','Falk','Bernhardt','m','Köln','Auf dem Hügel','0221/2345690',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','Müller','Tobias','m','Köln','Bennstr','0221/5566123',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Franz','Helga','w','Köln','Bahnhofstr.','0221/5566901',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('5','Sündbald','Hannelore','w','Gummersbach','Luisenstr','02261/4588',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('6','Wal','Birgit','w','Gummersbach','Löh','02261/4471',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('7','Tisch','Hartmut','m','Gladbeck','Agathastr.','02271/75613',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into KUNDEN_LEON
SET DEFINE OFF;
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','Tholler','Andreas','m','Köln','Belaweg','0221/956788',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','Falk','Bernhardt','m','Köln','Auf dem Hügel','0221/2345690',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','Müller','Tobias','m','Köln','Bennstr','0221/5566123',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Franz','Helga','w','Köln','Bahnhofstr.','0221/5566901',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('5','Sündbald','Hannelore','w','Gummersbach','Luisenstr','02261/4588',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('6','Wal','Birgit','w','Gummersbach','Löh','02261/4471',to_date('27.07.18','DD.MM.RR'));
Insert into KUNDEN_LEON (KUN_NR,NACHNAME,VORNAME,GESCHLECHT,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('7','Tisch','Hartmut','m','Gladbeck','Agathastr.','02271/75613',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into LAGER
SET DEFINE OFF;
Insert into LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('1','HauptLager','Köln','Eibenweg');
Insert into LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('2','NebenLager','Gummersbach','Am Sandberg');
Insert into LAGER (LANR,BEZEICHNUNG,ORT,STRASSE) values ('3','VerladeLager','Dortmund','Hansastr.');
REM INSERTING into LAGERBESTAND
SET DEFINE OFF;
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','1','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','31','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','57','1000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('1','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','55','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','56','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','57','1000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','1','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','31','2000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','54','1000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','60','899',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','61','1000',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('3','58','899',to_date('27.07.18','DD.MM.RR'));
Insert into LAGERBESTAND (LANR,TNR,BESTAND,ZEITSTEMPEL) values ('2','1','4000',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into LIEFERANTEN
SET DEFINE OFF;
Insert into LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('1','West-Ost-Handel','Köln','Eibenweg','0221/985688',to_date('27.07.18','DD.MM.RR'));
Insert into LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('2','IMPORT-Wendel','Dortmund','Kölner Str.','0221/76499',to_date('27.07.18','DD.MM.RR'));
Insert into LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('3','Quarks','Gummersbach','Mühle','02261/6711',to_date('27.07.18','DD.MM.RR'));
Insert into LIEFERANTEN (LIEF_NR,NAME,ORT,STRASSE,TELEFONNR,ZEITSTEMPEL) values ('4','Wahle','Remscheid','Lenneperstr.',null,to_date('27.07.18','DD.MM.RR'));
REM INSERTING into LIEFERPROGRAMME
SET DEFINE OFF;
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','3','7','2','5',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','4','9','5','6',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','5','11','1230','7',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','24','49','18','26',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','7','15','18','9',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','8','17','150','10',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','9','19','5','11',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','10','21','79','12',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','12','25','0,5','14',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','13','27','0,6','15',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','14','29','0,5','16',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','15','31','22','17',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','16','33','28','18',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','17','35','28','19',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','18','37','109','20',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','19','39','10','21',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','20','41','11','22',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','21','43','110','23',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','22','45','60','24',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','28','57','29','30',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','23','47','28','25',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','25','51','149','27',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','26','53','299','28',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','27','55','69','29',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','29','59','1590','31',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','30','61','2590','32',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','33','67','2','35',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','34','69','8','36',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','35','71','30','37',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','36','73','18','38',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','37','75','19','39',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','38','77','252','40',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','39','79','9','41',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','40','81','9','42',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','42','85','0,5','44',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','43','87','0,6','45',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','44','89','0,5','46',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','45','91','22','47',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','46','93','28','48',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','47','95','70','49',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','48','97','140','50',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','49','99','10','51',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','50','101','17','52',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','51','103','150','53',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','52','105','80','54',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('2','53','107','30','55',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','3','20','12','16',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','4','21','15','15',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','5','22','1240','14',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','7','24','28','12',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','8','25','160','11',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','9','26','15','10',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','10','27','89','9',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','12','29','10,5','7',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','13','30','10,6','6',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','14','31','10,5','5',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','15','32','32','4',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','16','33','38','3',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','17','34','38','2',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','18','35','119','1',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','19','36','20','0',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','20','37','21','1',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','21','38','120','2',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','22','39','70','3',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','23','40','38','4',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('1','24','41','28','5',to_date('28.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','33','297','2,2','59',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','34','306','8,8','61',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','35','315','33','63',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','36','324','19,8','65',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','37','333','20,9','67',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','38','342','277,2','69',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','39','351','9,9','71',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','40','360','9,9','73',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','42','378','0,55','77',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','43','387','0,66','79',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','44','396','0,55','81',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','45','405','24,2','83',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','46','414','30,8','85',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','47','423','77','87',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','48','432','154','89',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','49','441','11','91',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','50','450','18,7','93',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','51','459','165','95',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','52','468','88','97',to_date('29.07.18','DD.MM.RR'));
Insert into LIEFERPROGRAMME (LIEF_NR,TNR,BESTELLNR,EINKAUFSPREIS,GESAMTMENGE,ZEITSTEMPEL) values ('3','53','477','33','99',to_date('29.07.18','DD.MM.RR'));
REM INSERTING into LIEFERUNGEN
SET DEFINE OFF;
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('1','1','12',to_date('19.09.18','DD.MM.RR'),'1',to_date('08.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('2','1','13',to_date('19.09.18','DD.MM.RR'),'1',to_date('09.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('3','1','14',to_date('19.09.18','DD.MM.RR'),'1',to_date('10.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('4','1','15',to_date('19.09.18','DD.MM.RR'),'1',to_date('11.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('5','1','16',to_date('19.09.18','DD.MM.RR'),'1',to_date('12.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('6','1','17',to_date('19.09.18','DD.MM.RR'),'1',to_date('13.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('7','1','18',to_date('19.09.18','DD.MM.RR'),'1',to_date('14.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('8','1','19',to_date('19.09.18','DD.MM.RR'),'1',to_date('15.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('9','1','20',to_date('19.09.18','DD.MM.RR'),'1',to_date('16.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('10','1','21',to_date('19.09.18','DD.MM.RR'),'1',to_date('17.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('11','1','22',to_date('19.09.18','DD.MM.RR'),'1',to_date('18.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('12','1','23',to_date('19.09.18','DD.MM.RR'),'1',to_date('19.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('13','1','24',to_date('19.09.18','DD.MM.RR'),'1',to_date('20.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('14','2','24',to_date('18.09.18','DD.MM.RR'),'2',to_date('20.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('15','2','12',to_date('18.09.18','DD.MM.RR'),'2',to_date('08.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('16','2','13',to_date('18.09.18','DD.MM.RR'),'2',to_date('09.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('17','2','14',to_date('18.09.18','DD.MM.RR'),'2',to_date('10.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('18','2','15',to_date('18.09.18','DD.MM.RR'),'2',to_date('11.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('19','2','16',to_date('18.09.18','DD.MM.RR'),'2',to_date('12.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('20','2','17',to_date('18.09.18','DD.MM.RR'),'2',to_date('13.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('21','2','18',to_date('18.09.18','DD.MM.RR'),'2',to_date('14.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('22','2','19',to_date('18.09.18','DD.MM.RR'),'2',to_date('15.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('23','2','20',to_date('18.09.18','DD.MM.RR'),'2',to_date('16.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('24','2','21',to_date('18.09.18','DD.MM.RR'),'2',to_date('17.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('25','2','22',to_date('18.09.18','DD.MM.RR'),'2',to_date('18.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('26','2','28',to_date('18.09.18','DD.MM.RR'),'2',to_date('24.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('27','2','23',to_date('18.09.18','DD.MM.RR'),'2',to_date('19.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('28','2','25',to_date('18.09.18','DD.MM.RR'),'2',to_date('21.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('29','2','26',to_date('18.09.18','DD.MM.RR'),'2',to_date('22.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('30','2','27',to_date('18.09.18','DD.MM.RR'),'2',to_date('23.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('31','2','29',to_date('18.09.18','DD.MM.RR'),'2',to_date('25.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('32','2','30',to_date('18.09.18','DD.MM.RR'),'2',to_date('26.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('33','2','33',to_date('18.09.18','DD.MM.RR'),'2',to_date('29.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('34','2','34',to_date('18.09.18','DD.MM.RR'),'2',to_date('30.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('35','2','35',to_date('18.09.18','DD.MM.RR'),'2',to_date('31.08.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('36','2','36',to_date('18.09.18','DD.MM.RR'),'2',to_date('01.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('37','2','37',to_date('18.09.18','DD.MM.RR'),'2',to_date('02.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('38','2','38',to_date('18.09.18','DD.MM.RR'),'2',to_date('03.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('39','2','39',to_date('18.09.18','DD.MM.RR'),'2',to_date('04.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('40','2','40',to_date('18.09.18','DD.MM.RR'),'2',to_date('05.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('41','2','42',to_date('18.09.18','DD.MM.RR'),'2',to_date('07.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('42','2','43',to_date('18.09.18','DD.MM.RR'),'2',to_date('08.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('43','2','44',to_date('18.09.18','DD.MM.RR'),'2',to_date('09.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('44','2','45',to_date('18.09.18','DD.MM.RR'),'2',to_date('10.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('45','2','46',to_date('18.09.18','DD.MM.RR'),'2',to_date('11.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('46','2','47',to_date('18.09.18','DD.MM.RR'),'2',to_date('12.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('47','2','48',to_date('18.09.18','DD.MM.RR'),'2',to_date('13.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('48','2','49',to_date('18.09.18','DD.MM.RR'),'2',to_date('14.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('49','2','50',to_date('18.09.18','DD.MM.RR'),'2',to_date('15.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('50','2','51',to_date('18.09.18','DD.MM.RR'),'2',to_date('16.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('51','2','52',to_date('18.09.18','DD.MM.RR'),'2',to_date('17.09.18','DD.MM.RR'));
Insert into LIEFERUNGEN (LIEFER_NR,LIEF_NR,TNR,LIEF_DATUM,MENGE,ZEITSTEMPEL) values ('52','2','53',to_date('18.09.18','DD.MM.RR'),'2',to_date('18.09.18','DD.MM.RR'));
REM INSERTING into ORA_ERROR
SET DEFINE OFF;
Insert into ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-922',null,null,'ORA-00922: Fehlende oder ungültige Option');
Insert into ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-1031',null,null,'ORA-01031: Nicht ausreichende Berechtigungen');
Insert into ORA_ERROR (ORA_ERROR_ID,ERROR_HINT_ID,COUNTER,ERROR_TEXT) values ('-900',null,null,'ORA-00900: Ungültige SQL-Anweisung');
REM INSERTING into ORTE
SET DEFINE OFF;
Insert into ORTE (ORT,STRASSE,PLZ) values ('Gummersbach','Löh',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Gladbeck','Agathastr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Köln','Bennstr',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Gummersbach','Luisenstr',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Köln','Belaweg',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Köln','Bahnhofstr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Köln','Auf dem Hügel',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Leverkusen','Netzestr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Falkenstr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Prellerstr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Grubenfeld',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Burgstr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Planckstr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Plutostr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Dortmund','Bedastr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Erntestr.',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Bergisch Gladbach','Fichtenweg',null);
Insert into ORTE (ORT,STRASSE,PLZ) values ('Leverkusen','Quarzstr.',null);
REM INSERTING into OUTPUT_TABLE
SET DEFINE OFF;
REM INSERTING into POSITIONSARCHIV
SET DEFINE OFF;
REM INSERTING into PROC_CALLS
SET DEFINE OFF;
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('4','1','parameter(''EinTest'')');
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('6','1','hello_world');
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('5','1','transform_name(''Peter'',''Meier'')');
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('3','1','jahre');
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('1','1','gehaltsnachteile');
Insert into PROC_CALLS (QUESTIONID,EXECORDER,CALL) values ('2','1','nachnamen');
REM INSERTING into PROC_QUESTIONS
SET DEFINE OFF;
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('4','Schreiben Sie eine Prozedur mit dem Namen "parameter", die einen ihr übergebenen String ausgibt.','output_table','parameter','CREATE OR REPLACE PROCEDURE parameter (p1 VARCHAR2)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE(p1);
END;','procedure
','output_table');
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('5','Schreiben Sie eine Prozedur mit dem Namen "transform_name", der zwei Textvariablen für Nachname und Vorname übergeben werden und die als Ergebnis beide Variable hintereinandergeschrieben (Nachname, Vorname), getrennt durch ein Komma und in Großbuchstaben umgewandelt wieder ausgibt!','output_table','transform_name','CREATE OR REPLACE PROCEDURE transform_name (p_vorname  IN VARCHAR2, p_nachname  IN VARCHAR2)
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(UPPER(p_nachname)||'', ''||UPPER(p_vorname));
END;','procedure','output_table');
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('3','Schreiben Sie eine Prozedur mit dem Namen "jahre", die alle Angestellten (Vorname, Nachname ) der letzten 25 Jahre getrennt durch ein Komma und ein Blank, ausgibt. Benutzte Spalte: Eintrittsdatum. Benutzen Sie dabei einen Cursor und berücksichtigen Sie, dass die Differenz von zwei Date-Spalten in Tagen ausgegeben wird!','output_table','jahre','create or replace PROCEDURE jahre
IS
   CURSOR c_angestellte
   IS
      SELECT nachname, vorname
        FROM angestellte
       WHERE eintrittsdatum >= SYSDATE - 25 * 360;

   v_nachname   angestellte.nachname%TYPE;
   v_vorname    angestellte.vorname%TYPE;
BEGIN
   OPEN c_angestellte;
   FETCH c_angestellte INTO v_nachname, v_vorname;
   WHILE c_angestellte%FOUND
   LOOP
      DBMS_OUTPUT.PUT_LINE (v_vorname || '', '' || v_Nachname);
      FETCH c_angestellte INTO v_nachname, v_vorname;
   END LOOP;

   CLOSE c_angestellte;
END;
','procedure','angestellte,output_table');
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('6','Schreiben Sie eine PL/SQL-Prozedur mit dem Namen "hello_world", die "Hello World" ausgibt.','output_table','hello_world','CREATE PROCEDURE hello_world
IS
BEGIN
DBMS_OUTPUT.PUT_LINE(''Hello World'');
END;','procedure','output_table');
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('1','Schreiben Sie eine Prozedur mit dem Namen "gehaltsnachteile", die alle Nachnamen von Frauen ausgibt, die bei Ausübung des gleichen Berufs ein geringeres Gehalt als ein Mann haben.
Die Prozedur sollte zeilenweise "Frauenname"  "Männername" ausgeben.','output_table','gehaltsnachteile','CREATE OR REPLACE PROCEDURE gehaltsnachteile IS
V_frauenname VARCHAR2(50);
V_maennername VARCHAR2(50);
CURSOR geh_nachteile IS SELECT f.nachname Fnachname,
                   m.nachname Mnachname
                   FROM angestellte f, angestellte m
                   WHERE UPPER(f.geschlecht) = ''W''
                   AND UPPER(m.geschlecht) = ''M''
                   AND m.beruf = f.beruf
                   AND f.gehalt < m.gehalt;
BEGIN
OPEN geh_nachteile;
FETCH geh_nachteile INTO V_frauenname, V_maennername;
WHILE geh_nachteile%FOUND LOOP
DBMS_OUTPUT.PUT_LINE(V_frauenname|| '' '' || V_maennername);
FETCH geh_nachteile INTO V_frauenname, V_maennername;
END LOOP;
CLOSE geh_nachteile;
END;','procedure','angestellte,output_table');
Insert into PROC_QUESTIONS (QUESTIONID,TEXT,TESTTABLE,PROCNAME,SAMPLEPROC,QUESTIONTYP,NEEDEDTABLE) values ('2','Schreiben Sie eine Prozedur mit dem Namen "angestellte", die zuerst den Text "Nachnamen"  ausgibt, und danach alle Nachnamen aus der Tabelle "angestellte".','output_table','nachnamen','CREATE OR REPLACE PROCEDURE nachnamen IS
nachname VARCHAR2(50);
CURSOR namen IS SELECT nachname FROM angestellte;
BEGIN
DBMS_OUTPUT.PUT_LINE(''Nachnamen'');
OPEN namen;
FETCH namen INTO nachname;
WHILE namen%FOUND LOOP
DBMS_OUTPUT.PUT_LINE(nachname);
FETCH namen INTO nachname;
END LOOP;
CLOSE namen;
END;','procedure','angestellte,output_table');
REM INSERTING into QUESTIONS
SET DEFINE OFF;
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('11','Erstellen Sie einen Trigger mit dem Namen "trg_view_rechnung" auf der View "Rechnungen", welcher die Menge in der Tabelle "Auftragspositionen" anpasst, wenn versucht wird, dieses Feld in der View selber zu ändern.','Auftragspositionen','trg_view_rechnung','CREATE OR REPLACE TRIGGER trg_view_rechnung
  INSTEAD OF UPDATE  ON Rechnungen
DECLARE
BEGIN
   UPDATE Auftragspositionen
    SET MENGE = :NEW.MENGE
WHERE AUFTRAGSNR = :NEW.AUFTRAGSNR AND TNR = :NEW.TNR ;

END;','Trigger - View','Rechnungen,Auftragspositionen');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('12','Erstellen Sie einen Trigger mit dem Namen "trg_view_auftrag" auf der View "Rechnungen", welcher einen neuen Eintrag in der Tabelle Auftragspositionen macht, wenn versucht wird, in der View einen neuen Datensatz anzulegen.','Auftragspositionen','trg_view_auftrag','CREATE OR REPLACE TRIGGER trg_view_auftrag
  INSTEAD OF INSERT ON Rechnungen
   DECLARE
   BEGIN

   INSERT INTO Auftragspositionen VALUES
      ( :NEW.TNR, :NEW.AUFTRAGSNR, :NEW.MENGE);

END;','Trigger - View','Rechnungen,Auftragspositionen');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('2','Abteilungsleiter müssen einer Mindestgehaltsgruppe angehören.
Beim Hinzufügen einer neuen Abteilung oder wenn sich der Leiter einer Abteilung ändert soll mit dem Trigger "trg_leiter_gehalt" geprüft werden, ob das Gehalt des Abteilungleiters mindestens in die Gehaltsgruppe 3 fällt. Ist das Gehalt zu niedrig, so soll es auf das Mindestgehalt dieser Gehaltsgruppe erhöht werden.','Angestellte','trg_leiter_gehalt','create or replace TRIGGER trg_leiter_gehalt
AFTER INSERT OR UPDATE ON ABTEILUNGEN
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
  geh number;
  gehmin number;
BEGIN
  select gehalt into geh from angestellte where ang_nr=:neu.leiter;
  select min_gehalt into gehmin from geh_klassen where geh_klasse=3;
  if (geh < gehmin) then
    update angestellte set gehalt=gehmin where ang_nr=:neu.leiter;
  END IF;
END;','Trigger - Tabelle','Angestellte,Abteilungen,Geh_klassen');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('3','Folgeverarbeitung bei Bestandsänderung.
Wenn sich der Bestand eines Teils in der Tabelle Lagerbestand ändert, soll der Bestand in der Tabelle Teile automatisch mit angepasst werden. Der Trigger soll
unter dem Namen "trg_bestand_update" erstellt werden.','Teile','trg_bestand_update','CREATE OR REPLACE TRIGGER trg_bestand_update
AFTER UPDATE OF Bestand ON Lagerbestand
FOR EACH ROW
BEGIN
	UPDATE Teile
	SET Bestand =:NEW.Bestand -:OLD.Bestand + Bestand
	WHERE TNr =:NEW.TNr;
END;','Trigger - Tabelle','Teile,Lagerbestand');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('1','Die Summer aller Gehälter darf ein bestimmtes Budget nicht überschreiten.

Es soll ein Trigger "trg_budget_check" erstellt werden, der beim Hinzufügen eines neuen Mitarbeiters in der
Tabelle "Angestellte" und gleichzeitigem Überschreitung eines Gesamtbudgets von 100.000€ der Abteilung angestossen wird. In diesem Fall sollen alle Gehälter, die höher als 5000€ sind, auf 5000€ gekürzt werden.','Angestellte','trg_budget_check','create or replace TRIGGER trg_budget_check
AFTER INSERT ON Angestellte
DECLARE
   v_sum NUMBER;
BEGIN
SELECT SUM(gehalt) INTO v_sum FROM Angestellte;
IF v_sum > 100000 THEN
UPDATE Angestellte SET gehalt=5000 where gehalt > 5000;
END IF;
END;','Trigger - Tabelle','Angestellte');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('4','Folgeverarbeitung vollständig bezahlter Rechnungen.
Der Trigger "trg_umsatz_update" soll, sobald ein Kunde den Rechnungsbetrag eines Auftrags vollständig
gezahlt hat, in der Tabelle Artikel die im Auftrag umgesetzten Mengen zum Jahresumsatz hinzu addieren.','Artikel','trg_umsatz_update','CREATE OR REPLACE TRIGGER trg_umsatz_update
BEFORE INSERT OR UPDATE ON AUFTRAEGE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
rechnungssumme number;
BEGIN
  if (:alt.bereits_gezahlt <> :neu.bereits_gezahlt) then
    select SUM(Gesamt) into rechnungssumme from (select auftragspositionen.tnr,auftragspositionen.menge,artikel.verkaufspreis,
    (auftragspositionen.menge*artikel.verkaufspreis) as gesamt  from auftragspositionen inner join
    artikel on auftragspositionen.tnr=artikel.tnr where auftragspositionen.auftragsnr=:neu.auftragsnr);
    if (rechnungssumme = :neu.bereits_gezahlt) then
      update artikel set jahresumsatz=jahresumsatz + (select menge from auftragspositionen where AUFTRAGSNR=:neu.auftragsnr
      and auftragspositionen.TNR = Artikel.TNR) where tnr in (select tnr from auftragspositionen where auftragsnr=:neu.auftragsnr);
    end if;
  end if;
END;','Trigger - Tabelle','Artikel,Auftraege,Auftragspositionen');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('5','Gehaltserhöhungen müssen mindestens in einer Höhe von 10% erfolgen.
Bei Erhöhung des Gehalts eines Angestellten soll durch den Trigger "trg_erh_gehalt" geprüft werden, ob diese
Regelung eingehalten wurde. Sollte der neue Wert zu niedrig sein, soll das Gehalt des Angestellten
automatisch um dieses Minimum erhöht werden. ','Angestellte','trg_erh_gehalt','CREATE OR REPLACE TRIGGER trg_erh_gehalt
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
DECLARE
erh number;
erh_min number;
BEGIN
  if (:alt.gehalt < :neu.gehalt) then
    erh := :neu.gehalt - :alt.gehalt;
    erh_min := :alt.gehalt * 0.1;
    if (erh < erh_min) then
      :neu.gehalt := :alt.gehalt + erh_min;
    end if;
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('6','Archivierung gelöschter Auftragspositionen.
Wenn ein Datensatz aus der Tabelle "Auftragspositionen" gelöscht wird, sollen die gelöschten Datensätz durch den
Trigger "trg_pos_archiv" in der Tabelle "Positionsarchiv" archiviert werden.','Positionsarchiv','trg_pos_archiv','CREATE OR REPLACE TRIGGER trg_pos_archiv
AFTER DELETE ON AUFTRAGSPOSITIONEN
REFERENCING OLD AS alt
FOR EACH ROW
BEGIN
  insert into POSITIONSARCHIV values (:alt.auftragsnr, :alt.tnr, :alt.menge);
END;','Trigger - Tabelle','Auftragspositionen,Positionsarchiv');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('7','Protokollierung von Gehaltsänderungen.
Wenn in der Tabelle Angestellte Änderungen in der Spalte "Gehalt" vorgenommen werden, soll die betreffende Ang_Nr, die Gehaltsveränderung d.h. altes Gehalt und neues Gehalt sowie das aktuelle Tagesdatum, durch den Trigger "trg_geh_prot", in der Tabelle "Gehaltsprotokoll" protokolliert werden.

Info: Aktuelles Tagesdatum über TO_CHAR(sysdate) einfügen.','Gehaltsprotokoll','trg_geh_prot','CREATE OR REPLACE TRIGGER trg_geh_prot
AFTER UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:alt.gehalt <> :neu.gehalt) then
    insert into GEHALTSPROTOKOLL values (:alt.ang_nr, :alt.gehalt , :neu.gehalt , TO_CHAR(sysdate));
  end if;
END;','Trigger - Tabelle','Angestellte,Gehaltsprotokoll');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('8','Gehälter dürfen nicht sinken.
Durch den Trigger "trg_geh_check" soll sichergestellt werden,  dass in der Spalte Gehalt in der Tabelle
"Angestellte"  kein niedrigerer Wert als der bisherige eingetragen wird. In diesem Fall soll eine
Ausnahme mit der ID:-20001 und dem Text:"Gehälter dürfen nicht sinken" ausgelöst werden.','exception','trg_geh_check','CREATE OR REPLACE TRIGGER trg_geh_check
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:neu.gehalt < :alt.gehalt) then
    RAISE_APPLICATION_ERROR(-20001,''Gehälter dürfen nicht sinken'');
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('9','Personalnummern dürfen nicht geändert werden.
Durch den Trigger "trg_ang_nr_check" soll verhindert werden, dass die Spalte "Ang_Nr" in der Tabelle
Angestellte nachträglich geändert wird. In diesem Fall soll eine Ausnahme mit der ID:-20001 und
dem Text:"Personalnummern dürfen nicht geändert werden" ausgelöst werden.','exception','trg_ang_nr_check','CREATE OR REPLACE TRIGGER trg_ang_nr_check
BEFORE UPDATE ON ANGESTELLTE
REFERENCING OLD AS alt NEW AS neu
FOR EACH ROW
BEGIN
  if (:neu.ang_nr <> :alt.ang_nr) then
    RAISE_APPLICATION_ERROR(-20001,''Personalnummern dürfen nicht geändert werden'');
  end if;
END;','Trigger - Tabelle','Angestellte');
Insert into QUESTIONS (QUESTIONID,TEXT,TESTTABLE,TRIGGERNAME,SAMPLETRIGGER,QUESTIONTYP,NEEDEDTABLE) values ('10','Gehaltsklassen dürfen sich nicht überschneiden.
Der Trigger "trg_geh_klassen" soll beim Einfügen/Ändern eines Datensatzes in der Tabelle geh_klassen die neuen bzw. geänderten Zeilen prüfen, ob sich hierdurch Überschneidungen
zu anderen Gehaltsklassen ergeben. Sollte dies der Fall sein, soll der Trigger eine Exception mit der ID: -20001 und dem Text: "Gehaltsklassen dürfen sich nicht überschneiden" auslösen.
(Tipp: Verwenden Sie zur Lösung einen autonomen Row-Trigger)','exception','trg_geh_klassen','CREATE OR REPLACE TRIGGER trg_geh_klassen
   BEFORE INSERT OR UPDATE
   ON geh_klassen
   FOR EACH ROW
DECLARE
   v_anzahl   NUMBER (5) DEFAULT 0;
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   SELECT   COUNT ( * )
     INTO   v_anzahl
     FROM   geh_klassen
    WHERE   (:NEW.min_gehalt BETWEEN min_gehalt AND max_gehalt
             OR :NEW.max_gehalt BETWEEN min_gehalt AND max_gehalt);
   COMMIT;
   IF v_anzahl > 1
   THEN
      RAISE_APPLICATION_ERROR (
         -20001,''Gehaltsklassen dürfen sich nicht überschneiden'');
   END IF;
END;','Trigger - Tabelle','Geh_klassen');
REM INSERTING into STRUKTUR
SET DEFINE OFF;
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','2','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('2','3','2','10','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('2','4','3','20','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','5','4','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','24','5','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','7','6','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','8','7','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','9','8','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','10','9','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','11','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','16','11','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','17','12','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','18','13','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','19','14','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','20','15','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','21','16','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','22','17','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('1','23','18','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','12','1','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','13','2','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','14','3','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('11','15','4','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','32','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('32','33','2','10','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('32','34','3','20','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','35','4','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','44','5','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','37','6','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','38','7','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','39','8','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','40','9','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','41','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','46','11','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','47','12','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','48','13','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','49','14','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','50','15','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','51','16','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','52','17','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('31','53','18','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','42','1','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','43','2','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','44','3','50','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('41','45','4','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','2','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','41','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('60','62','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('62','49','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('62','40','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('40','34','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into STRUKTUR (OTEIL,UTEIL,POSITION,MENGE,AUSSCHUSS,ARBEITSGANG,ZEITSTEMPEL) values ('40','3','1','1','0','0',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into TEILE
SET DEFINE OFF;
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('1','Stück','Rocky Mountain Element Race','Artikel','2600','0','10','8000','20','20','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('2','Stück','Rahmen Element Race','Baugruppe','300','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('3','kg','Silberfarbe','Material','0','2','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('4','kg','Sintermetall','Material','0','5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('5','Stück','Gabel SID XC','Material','0','1230','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('24','Stück','TretLager Race Face','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('7','Stück','Kurbelsatz Race Face','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('8','Stück','Schaltwerk XTR','Material','0','150','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('9','Stück','Pedale Shimano 747','Material','0','5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('10','Stück','Schalthebel Grip Shift','Material','0','79','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('11','Stück','Rad xtr','Baugruppe','50','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('12','Stück','Naben Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('13','Stück','Felgen Mavic Crossmax','Material','0','0,6','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('14','Stück','Speichen Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('15','Stück','Bereifung Richtey, Vo: Z-Max ','Material','0','22','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('16','Stück','Steuersatz Chris King','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('17','Stück','Vorbau Control Tech','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('18','Stück','Lenker Answer Hyperlite','Material','0','109','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('19','Stück','Griffe LGrip Shift ','Material','0','10','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('20','Stück','Bremshebel XTR','Material','0','11','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('21','Stück','Bremsen XTR','Material','0','110','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('22','Stück','Sattel Flite','Material','0','60','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('28','Stück','Bremse Shimano Alivio Cantilever ','Material','0','29','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('23','Stück','Sattelstütze Syncros','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('25','Stück','Bremse Shimano XTR V-Brake ','Material','0','149','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('26','Stück','GABEL TOP GUN ','Material','0','299','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('27','Stück','Shimano STX-RC i','Material','0','69','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('29','Stück','Rahmen Cannondale CAD3 Headshok','Material','0','1590','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('30','Stück','Rahmen Super V','Material','0','2590','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('31','Stück','Herrenrad GT-LTS 18','Artikel','3000','0','10','4000','20','20','2','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('32','Stück','Rahmen GT-LTS 18"','Baugruppe','300','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('33','kg','Vb-Farbe','Material','0','2','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('34','kg','Aluminium','Material','0','8','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('35','Stück','RST Hi-5','Material','0','30','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('36','Stück','Race Face (TITAN)','Material','0','18','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('37','Stück','Kurbelsatz Ritchey Logic','Material','0','19','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('38','Stück','Schaltwerk XTR inverse','Material','0','252','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('39','Stück','Pedale XT','Material','0','9','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('40','Stück','Schalthebel Grip Shift 4','Material','0','9','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('41','Stück','Rad XTR 47','Baugruppe','60','0','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('42','Stück','Naben Inferno','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('43','Stück','Felgen Inferno','Material','0','0,6','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('44','Stück','Speichen Mavic Crossmax','Material','0','0,5','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('45','Stück','Bereifung Continental ','Material','0','22','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('46','Stück','Steuersatz Race Face','Material','0','28','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('47','Stück','Vorbau Syncros','Material','0','70','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('48','Stück','Lenker Syncros (Downhill)','Material','0','140','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('49','Stück','Griffe LGrip Shift ','Material','0','10','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('50','Stück','Bremshebel TWP G-Force','Material','0','17','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('51','Stück','Bremsen Magura Race Line','Material','0','150','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('52','Stück','Sattel Selle Flite Titanium','Material','0','80','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('53','Stück','Sattelstütze XTR','Material','0','30','10','10','10','10','1','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('54','Stück','Klapprad Prompton P3','Artikel','0','1200','10','1000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('55','Stück','CANNONDALE FSL','Artikel','0','4200','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('56','Stück','HERCULES NEPAL','Artikel','0','1200','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('57','Stück','Steppenwolf TAO','Artikel','0','1600','10','2000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('58','Stück','SWITCHBACK AGENT','Artikel','0','599','10','2697','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('59','Stück','STEVENS R.P.R.2 RX100 8FACH','Artikel','0','1700','10','10','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('60','Stück','Scott ATACAMA TOUR','Artikel','0','1899','10','899','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('61','Stück','ROTWILD RCC-03','Artikel','0','3280','10','1000','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
Insert into TEILE (TNR,ME,BEZEICHNUNG,TYP,HERSTELLKOSTEN,EINKAUFSPREIS,MINDESTBESTAND,BESTAND,LIEFERZEIT,HERSTELLDAUER,GEWICHT,RESERVIERT,VERFUEGBAR,ZEITSTEMPEL) values ('62','Stück','Lenker','Baugruppe','0','280','10','10','10','10','0','0','0',to_date('27.07.18','DD.MM.RR'));
REM INSERTING into TEILE_WERKE
SET DEFINE OFF;
Insert into TEILE_WERKE (TNR,WNR) values ('2','1');
Insert into TEILE_WERKE (TNR,WNR) values ('2','2');
Insert into TEILE_WERKE (TNR,WNR) values ('11','1');
Insert into TEILE_WERKE (TNR,WNR) values ('32','1');
Insert into TEILE_WERKE (TNR,WNR) values ('41','1');
Insert into TEILE_WERKE (TNR,WNR) values ('41','2');
REM INSERTING into WERKE
SET DEFINE OFF;
Insert into WERKE (WNR,BEZEICHNUNG,ORT,STRASSE) values ('1','Montagewerk','Gladbeck','Adlerstr.');
Insert into WERKE (WNR,BEZEICHNUNG,ORT,STRASSE) values ('2','Vorfertigung','Gladbeck','Am Pferdekamp');
--------------------------------------------------------
--  DDL for Index ABT_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "ABT_PK" ON "ABTEILUNGEN" ("ABT_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index ANG_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "ANG_PK" ON "ANGESTELLTE" ("ANG_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FIRINGSTATEMENTS_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "FIRINGSTATEMENTS_PK" ON "FIRINGSTATEMENTS" ("QUESTIONID", "EXECORDER")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index FUNC_QUESTIONS_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "FUNC_QUESTIONS_PK" ON "FUNC_QUESTIONS" ("QUESTIONID")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index GE_PRO_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "GE_PRO_PK" ON "GEHALTSPROTOKOLL" ("ANG_NR", "DATUM")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index G_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "G_PK" ON "GEH_KLASSEN" ("GEH_KLASSE")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index KUN_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "KUN_PK" ON "KUNDEN" ("KUN_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LAG_PK" ON "LAGER" ("LANR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LAG_T_PK" ON "LAGERBESTAND" ("LANR", "TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LEON_KUN_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LEON_KUN_PK" ON "KUNDEN_LEON" ("KUN_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LG_PK" ON "LIEFERUNGEN" ("LIEFER_NR", "LIEF_NR", "TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LIEF_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LIEF_PK" ON "LIEFERANTEN" ("LIEF_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "LP_PK" ON "LIEFERPROGRAMME" ("LIEF_NR", "TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index O_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "O_PK" ON "ORTE" ("ORT", "STRASSE")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PA_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "PA_PK" ON "POSITIONSARCHIV" ("TNR", "AUFTRAGSNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index QUESTIONS_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "QUESTIONS_PK" ON "QUESTIONS" ("QUESTIONID")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index S_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "S_PK" ON "STRUKTUR" ("OTEIL", "UTEIL", "POSITION")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index TE_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "TE_PK" ON "TEILE" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "T_WE_PK" ON "TEILE_WERKE" ("TNR", "WNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index WE_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "WE_PK" ON "WERKE" ("WNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "AR_AU_PK" ON "AUFTRAGSPOSITIONEN" ("TNR", "AUFTRAGSNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "AR_PK" ON "ARTIKEL" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_PK
--------------------------------------------------------

CREATE UNIQUE INDEX "AU_PK" ON "AUFTRAEGE" ("AUFTRAGSNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_LIEF_FK_I
--------------------------------------------------------

CREATE INDEX "LG_LIEF_FK_I" ON "LIEFERUNGEN" ("LIEF_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_T_FK_I
--------------------------------------------------------

CREATE INDEX "LAG_T_T_FK_I" ON "LAGERBESTAND" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index KUNDEN_I
--------------------------------------------------------

CREATE INDEX "KUNDEN_I" ON "KUNDEN" ("VORNAME", "NACHNAME")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_T_FK_I
--------------------------------------------------------

CREATE INDEX "T_WE_T_FK_I" ON "TEILE_WERKE" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LAG_T_LAG_FK_I
--------------------------------------------------------

CREATE INDEX "LAG_T_LAG_FK_I" ON "LAGERBESTAND" ("LANR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_ANG_FK_I
--------------------------------------------------------

CREATE INDEX "AU_ANG_FK_I" ON "AUFTRAEGE" ("ANG_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_AR_FK_I
--------------------------------------------------------

CREATE INDEX "AR_AU_AR_FK_I" ON "AUFTRAGSPOSITIONEN" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_T_FK_I
--------------------------------------------------------

CREATE INDEX "LP_T_FK_I" ON "LIEFERPROGRAMME" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LP_LIEF_FK_I
--------------------------------------------------------

CREATE INDEX "LP_LIEF_FK_I" ON "LIEFERPROGRAMME" ("LIEF_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_WE_WE_FK_I
--------------------------------------------------------

CREATE INDEX "T_WE_WE_FK_I" ON "TEILE_WERKE" ("WNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index ANG_ABT_FK_I
--------------------------------------------------------

CREATE INDEX "ANG_ABT_FK_I" ON "ANGESTELLTE" ("ABT_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AR_AU_AU_FK_I
--------------------------------------------------------

CREATE INDEX "AR_AU_AU_FK_I" ON "AUFTRAGSPOSITIONEN" ("AUFTRAGSNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index STRUKTUR_I
--------------------------------------------------------

CREATE INDEX "STRUKTUR_I" ON "STRUKTUR" ("OTEIL", "UTEIL")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index AU_KUN_FK_I
--------------------------------------------------------

CREATE INDEX "AU_KUN_FK_I" ON "AUFTRAEGE" ("KUN_NR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index LG_T_FK_I
--------------------------------------------------------

CREATE INDEX "LG_T_FK_I" ON "LIEFERUNGEN" ("TNR")
    PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
    STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
    PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
    BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
    TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Procedure WI2630_GEHALTSNACHTEILE
--------------------------------------------------------
set define off;

CREATE OR REPLACE EDITIONABLE PROCEDURE "WI2630_GEHALTSNACHTEILE" WI2630_GEHALTSNACHTEILE
    IS
    V_GEHALT   ANGESTELLTE_WI2630.GEHALT%TYPE;
CURSOR TAB_CUR IS SELECT TABLE_NAME
                  FROM USER_TABLES;
BEGIN
    OPEN TAB_CUR;
    FETCH TAB_CUR INTO  V_GEHALT;
    WHILE TAB_CUR%FOUND LOOP
            IF V_GEHALT > 5000
            THEN
                EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('WI2630', V_GEHALT);
                FETCH TAB_CUR INTO  V_GEHALT;
            END IF;
        END LOOP;
    CLOSE TAB_CUR;
END;



/
--------------------------------------------------------
--  DDL for Procedure WI2630_HELLO_WORLD
--------------------------------------------------------
set define off;

CREATE OR REPLACE EDITIONABLE PROCEDURE "WI2630_HELLO_WORLD" WI2630_HELLO_WORLD
    IS
BEGIN
    EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('WI2630', 'HELLO WORLD');
END;

/
--------------------------------------------------------
--  DDL for Procedure WI2630_SAMPLE_GEHALTSNACHTEILE
--------------------------------------------------------
set define off;

CREATE OR REPLACE EDITIONABLE PROCEDURE "WI2630_SAMPLE_GEHALTSNACHTEILE" IS
    V_FRAUENNAME VARCHAR2(50);
    V_MAENNERNAME VARCHAR2(50);
    CURSOR GEH_NACHTEILE IS SELECT F.NACHNAME FNACHNAME,
                                   M.NACHNAME MNACHNAME
                            FROM ANGESTELLTE_SAMPLE_WI2630 F, ANGESTELLTE_SAMPLE_WI2630 M
                            WHERE UPPER(F.GESCHLECHT) = 'W'
                              AND UPPER(M.GESCHLECHT) = 'M'
                              AND M.BERUF = F.BERUF
                              AND F.GEHALT < M.GEHALT;
BEGIN
    OPEN GEH_NACHTEILE;
    FETCH GEH_NACHTEILE INTO V_FRAUENNAME, V_MAENNERNAME;
    WHILE GEH_NACHTEILE%FOUND LOOP
            EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('SAMPLE_WI2630', V_FRAUENNAME|| ' ' || V_MAENNERNAME);
            FETCH GEH_NACHTEILE INTO V_FRAUENNAME, V_MAENNERNAME;
        END LOOP;
    CLOSE GEH_NACHTEILE;
END;

/
--------------------------------------------------------
--  DDL for Procedure WI2630_SAMPLE_HELLO_WORLD
--------------------------------------------------------
set define off;

CREATE OR REPLACE EDITIONABLE PROCEDURE "WI2630_SAMPLE_HELLO_WORLD"
    IS
BEGIN
    EDB_PLSQL_PROC_APP.INSERT_INTO_OUTPUT_TABLE('SAMPLE_WI2630', 'HELLO WORLD');
END;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE BODY "EDB_PLSQL_APP" IS

    FUNCTION evaluate_question
    ( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2)
        RETURN sys_refcursor AS
        evaluation_result sys_refcursor;
        sample_trigger VARCHAR(4048);
        new_test_trigger VARCHAR(4048);
        table_name VARCHAR(128);
        l_needed_table VARCHAR(128);
        l_tablen  BINARY_INTEGER;
        l_tab DBMS_UTILITY.uncl_array;
        function_result NUMBER;
        result_diffrence NUMBER;
        message VARCHAR2(512);
        resultnumber NUMBER;
        exceptiontesttable NUMBER;
        exceptionreferencetable NUMBER;
        resulttesttable CLOB;
        resultreferencetable CLOB;
        v_object_type VARCHAR2(32);
    BEGIN

        SELECT SAMPLETRIGGER, UPPER(TESTTABLE), NEEDEDTABLE INTO sample_trigger, table_name, l_needed_table FROM QUESTIONS WHERE QUESTIONID = question_id;

        ---------------------------------------------------------------------
        -- Aufbau der benötigten Tabellen für den zu prüfenden Trigger ------
        ---------------------------------------------------------------------

        DBMS_UTILITY.comma_to_table (
                list   => l_needed_table,
                tablen => l_tablen,
                tab    => l_tab);

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table_if_exists(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

        ---------------------------------------------------------------------
        -- Der zu prüfende Trigger ------------------------------------------
        ---------------------------------------------------------------------

        new_test_trigger := test_trigger;

        FOR i IN 1 .. l_tablen LOOP
                new_test_trigger := REPLACE(UPPER(new_test_trigger),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
            END LOOP;

        function_result := create_trigger(REPLACE(UPPER(new_test_trigger),'TRIGGER ','TRIGGER '||identifier_key|| '_'),message);
        IF function_result = -1 THEN
            FOR i IN 1 .. l_tablen LOOP
                    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                    IF v_object_type = 'TABLE' THEN
                        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    ELSIF v_object_type = 'VIEW' THEN
                        function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
                    END IF;
                END LOOP;

            OPEN evaluation_result FOR
                Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;

            RETURN evaluation_result;
        END IF;

        function_result := fire_trigger(question_id,l_needed_table,identifier_key);
        IF function_result = -1 THEN
            exceptiontesttable := function_result;
        END IF;

        ---------------------------------------------------------------------
        -- Aufbau der benötigten Tabellen für den Sample Trigger ------------
        ---------------------------------------------------------------------

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table_if_exists(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                    function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                END IF;
            END LOOP;

        ---------------------------------------------------------------------
        -- Der Sample Trigger -----------------------------------------------
        ---------------------------------------------------------------------

        FOR i IN 1 .. l_tablen LOOP
                sample_trigger := REPLACE(UPPER(sample_trigger),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key|| '_res'));
            END LOOP;

        function_result := create_trigger(REPLACE(UPPER(sample_trigger),'TRIGGER ','TRIGGER '||identifier_key|| '_res_'),message);
        IF function_result = -1 THEN
            FOR i IN 1 .. l_tablen LOOP
                    SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                    IF v_object_type = 'TABLE' THEN
                        function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                    ELSIF v_object_type = 'VIEW' THEN
                        function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                    END IF;
                END LOOP;

            OPEN evaluation_result FOR
                Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;

            RETURN evaluation_result;
        END IF;

        function_result := fire_trigger(question_id,l_needed_table,identifier_key || '_res');
        IF function_result = -1 THEN
            exceptionreferencetable := function_result;
        END IF;

        ---------------------------------------------------------------------

        IF table_name <> 'EXCEPTION' THEN
            EXECUTE IMMEDIATE ' select count(*) from(
                            (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || '_res)
                            UNION ALL
                            (select * from ' || table_name || '_' || identifier_key || '_res MINUS select * from ' || table_name || '_' || identifier_key || ')
                            )' INTO result_diffrence;
        ELSE
            IF exceptionreferencetable <> exceptiontesttable THEN
                result_diffrence := -1;
            ELSE
                EXECUTE IMMEDIATE ' select count(*) from(
                                (select * from ' || l_needed_table || '_' || identifier_key || ' MINUS select * from ' || l_needed_table || '_' || identifier_key || '_res)
                                UNION ALL
                                (select * from ' || l_needed_table || '_' || identifier_key || '_res MINUS select * from ' || l_needed_table || '_' || identifier_key || ')
                                )' INTO result_diffrence;
                IF result_diffrence <> 0 THEN
                    table_name := l_needed_table;
                END IF;
            END IF;
        END IF;

        IF result_diffrence = 0 THEN
            message := 'Der Trigger hat das gewünschte Ergebniss zurück geliefert!';
            resultnumber := 1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        ELSE
            SELECT get_json_fnc('edb_plsql_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
            SELECT get_json_fnc('edb_plsql_app.get_table_data(''' || table_name || '_' || identifier_key || '_res'')') INTO resultreferencetable FROM DUAL;

            message := 'Der Trigger hat das falsche Ergebniss zurück geliefert!';
            resultnumber := -1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
        END IF;

        ---------------------------------------------------------------------
        -- Abbau der benötigten Tabellen ------------------------------------
        ---------------------------------------------------------------------

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key || '_res'));
                END IF;
            END LOOP;

        ---------------------------------------------------------------------
        RETURN evaluation_result;

    END evaluate_question;

    FUNCTION create_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
        command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
        EXECUTE IMMEDIATE command;
        EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
    END create_table;

    FUNCTION create_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
        EXECUTE IMMEDIATE command;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
    END create_view;

    FUNCTION delete_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! ('||sqlerrm||')');
    END delete_table;

    FUNCTION delete_table_if_exists
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        total number(2) := 0;
    BEGIN
        SELECT count(tname) into total from tab where tname = upper(table_name||'_'||identifier_key);
        IF total = 1 THEN
            EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
        END IF;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! ('||sqlerrm||')');
    END delete_table_if_exists;

    FUNCTION delete_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! (' || sqlerrm || ')');
    END delete_view;

    FUNCTION create_trigger
    ( trigger IN VARCHAR2, msg OUT VARCHAR )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE trigger;

        msg:= 'Erfolgreich: Der Trigger wurde ohne Fehler kompiliert!';
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        msg := 'Fehler: Der Trigger konnte nicht kompiliert werden! (' || sqlerrm || ')';
        RETURN -1;
    END create_trigger;

    FUNCTION fire_trigger
    ( question_id IN NUMBER, l_needed_table IN VARCHAR2, identifier_key IN VARCHAR2 )
        RETURN NUMBER AS
        test_statement VARCHAR2(1024);
        l_tablen  BINARY_INTEGER;
        l_tab DBMS_UTILITY.uncl_array;
        CURSOR test_statement_cursor IS
            SELECT FIRINGCODE
            FROM FIRINGSTATEMENTS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;
    BEGIN
        DBMS_UTILITY.comma_to_table (
                list   => l_needed_table,
                tablen => l_tablen,
                tab    => l_tab);

        OPEN test_statement_cursor;
        LOOP
            FETCH test_statement_cursor INTO test_statement;
            EXIT WHEN test_statement_cursor%NOTFOUND;
            FOR i IN 1 .. l_tablen LOOP
                    test_statement := REPLACE(UPPER(test_statement),UPPER(l_tab(i)),UPPER(l_tab(i) || '_' || identifier_key));
                END LOOP;
            EXECUTE IMMEDIATE test_statement;
        END LOOP;
        CLOSE test_statement_cursor;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        RETURN 1;
    END fire_trigger;

    FUNCTION get_question
    ( question_id IN NUMBER)
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    TRIGGERNAME ,
                    SAMPLETRIGGER  FROM QUESTIONS WHERE QUESTIONID = question_id;

        RETURN select_result;
    END get_question;

    FUNCTION get_questions
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    TRIGGERNAME ,
                    SAMPLETRIGGER  FROM QUESTIONS ORDER BY QUESTIONID ASC;

        RETURN select_result;
    END get_questions;

    FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

        RETURN select_result;
    END get_table_colum_names;

    FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
                'SELECT * FROM ' || v_table_name;

        RETURN select_result;
    END get_table_data;

    FUNCTION get_firing_statements
    ( question_id IN NUMBER )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT FIRINGCODE
            FROM FIRINGSTATEMENTS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;

        RETURN select_result;
    END get_firing_statements;

    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
    BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
            ,l_num_cols
            ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
            LOOP
                CASE
                    WHEN l_descr_tab(i).col_type IN (2
                        ,8) THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"number"},';
                    WHEN l_descr_tab(i).col_type = 12 THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"date"},';
                    ELSE
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"text"},';
                    END CASE;
                dbms_lob.writeappend(l_header_clob
                    ,length(l_row_data)
                    ,l_row_data);
            END LOOP;
        l_header_clob := rtrim(l_header_clob
                             ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
            ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
            ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
            ,'_x0020_'
            ,' ');
        dbms_lob.writeappend(l_header_clob
            ,length(l_ret_clob)
            ,l_ret_clob);
        RETURN l_header_clob;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            dbms_output.put_line(dbms_utility.format_error_backtrace);
            RETURN NULL;
    END get_json_fnc;

END edb_plsql_app;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_FUNC_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE BODY "EDB_PLSQL_FUNC_APP" IS

    FUNCTION create_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
        command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
        EXECUTE IMMEDIATE command;
        EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
    END create_table;

    FUNCTION delete_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        RETURN 1;
    -- raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! ('||sqlerrm||')');
    END delete_table;

    FUNCTION create_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
        EXECUTE IMMEDIATE command;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
    END create_view;

    FUNCTION delete_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! (' || sqlerrm || ')');
    END delete_view;

    FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

        RETURN select_result;
    END get_table_colum_names;

    FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
                'SELECT * FROM ' || v_table_name;

        RETURN select_result;
    END get_table_data;

    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
    BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
            ,l_num_cols
            ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
            LOOP
                CASE
                    WHEN l_descr_tab(i).col_type IN (2
                        ,8) THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"number"},';
                    WHEN l_descr_tab(i).col_type = 12 THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"date"},';
                    ELSE
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"text"},';
                    END CASE;
                dbms_lob.writeappend(l_header_clob
                    ,length(l_row_data)
                    ,l_row_data);
            END LOOP;
        l_header_clob := rtrim(l_header_clob
                             ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
            ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
            ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
            ,'_x0020_'
            ,' ');
        dbms_lob.writeappend(l_header_clob
            ,length(l_ret_clob)
            ,l_ret_clob);
        RETURN l_header_clob;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            dbms_output.put_line(dbms_utility.format_error_backtrace);
            RETURN NULL;
    END get_json_fnc;

    FUNCTION get_questions
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    FUNCTIONNAME ,
                    SAMPLEFUNCTION  FROM FUNC_QUESTIONS ORDER BY QUESTIONID ASC;

        RETURN select_result;
    END get_questions;

    FUNCTION get_question
    ( question_id IN NUMBER)
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    FUNCTIONNAME ,
                    SAMPLEFUNCTION  FROM FUNC_QUESTIONS WHERE QUESTIONID = question_id;

        RETURN select_result;
    END get_question;

    FUNCTION create_function
    ( function IN VARCHAR2, msg OUT VARCHAR )
        RETURN NUMBER AS
        error VARCHAR2(4000 BYTE);
        func VARCHAR2(1024);
        stmt VARCHAR2(1024);
    BEGIN
        func := REGEXP_SUBSTR(function, 'FUNCTION\s*(\w*)', 1, 1, NULL, 1);
        EXECUTE IMMEDIATE function;
        msg:= 'Erfolgreich: Die Funktion wurde ohne Fehler kompiliert!';
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        stmt := 'SELECT ''Zeile '' || line || '', Spalte '' || position || '' - '' || text FROM USER_ERRORS WHERE NAME = :funcname FETCH FIRST 1 ROWS ONLY';
        EXECUTE IMMEDIATE stmt INTO error USING func;
        msg := 'Fehler: Die Funktion konnte nicht kompiliert werden! (' || sqlerrm || ') - Details: ' || error || ')';
        EXECUTE IMMEDIATE 'DROP FUNCTION ' || func;
        RETURN -1;
    END create_function;

    FUNCTION delete_function
    ( function_name IN VARCHAR2, msg OUT VARCHAR )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP FUNCTION '||function_name;
        msg:= 'Erfolgreich: Die Funktion wurde ohne Fehler gelöscht!';
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        msg := 'Fehler: Die Funktion konnte nicht gelöscht werden! (' || sqlerrm || ')';
        RETURN -1;
    END delete_function;

    FUNCTION evaluate_question
    ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2)
        RETURN sys_refcursor AS
        evaluation_result sys_refcursor;
        user_result VARCHAR(4000 BYTE);
        mod_user_function VARCHAR(1024);
        sample_function VARCHAR(1024);
        mod_sample_function VARCHAR(1024);
        table_name VARCHAR(128);
        func_name VARCHAR(128);
        l_needed_table VARCHAR(128);
        l_tablen  BINARY_INTEGER;
        l_tab DBMS_UTILITY.uncl_array;
        function_result NUMBER;
        eval_result VARCHAR2(1024);
        message VARCHAR2(10000 BYTE);
        v_object_type VARCHAR2(32);
        v_func_call VARCHAR2(500);
        v_func_call_user VARCHAR2(500);
        v_func_call_sample VARCHAR2(500);
        result_difference NUMBER;
        resultnumber NUMBER;
        resulttesttable CLOB;
        resultreferencetable CLOB;
        sql_stmt VARCHAR2(512);
        CURSOR func_call_cursor IS
            SELECT CALL
            FROM FUNC_CALLS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;
    BEGIN

        -- select samplefunction (solution) from FUNCTIONQUESTION
        SELECT SAMPLEFUNCTION, UPPER(TESTTABLE), FUNCTIONNAME, NEEDEDTABLE INTO sample_function, table_name, func_name, l_needed_table
        FROM FUNC_QUESTIONS WHERE QUESTIONID = question_id;

-- mit komma getrennte liste (l_needed_table) wird hier geparst
        DBMS_UTILITY.comma_to_table (
                list   => l_needed_table,
                tablen => l_tablen,
                tab    => l_tab);

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                END IF;
            END LOOP;

-- erstellen der needed tables (identifier_key wird an tabellennamen angehangen)
        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := create_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

-- übergebene userfunktion muss vorbereitet werden -> mod_user_function
        mod_user_function := user_function;

        -- needed_tables mit identifier_key erweitern
        FOR i IN 1 .. l_tablen LOOP
                mod_user_function := REPLACE(UPPER(mod_user_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
            END LOOP;
        --   dbms_output durch eigenen Funktionsaufruf ersetzen
        -- mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_'||identifier_key||' VALUES');
        mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_func_app.insert_into_output_table('''||identifier_key||''', ' );
        --     DBMS_OUTPUT.PUT_LINE('buffer is: '||buffer);
        -- insert_into_output_table('abcd', 'buffer is: '||buffer);

        -- userfunction mit identifier_key erweitern und kompilieren
        function_result := create_function(REPLACE(UPPER(mod_user_function),'FUNCTION ','FUNCTION '||UPPER(identifier_key)||'_'),message);
        -- return on compilation error
        IF function_result = -1 THEN
            OPEN evaluation_result FOR
                Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
            RETURN evaluation_result;
        END IF;


        -- samplefunction mit identifier_key erweitern
        -- dbms_output durch inserts ersetzen
        mod_sample_function := sample_function;

        FOR i IN 1 .. l_tablen LOOP
                mod_sample_function := REPLACE(UPPER(mod_sample_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_SAMPLE_'||identifier_key));
            END LOOP;
        -- mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_SAMPLE_'||identifier_key||' VALUES');
        mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_func_app.insert_into_output_table(''SAMPLE_'||identifier_key||''', ' );
        -- insert_into_output_table('SAMPLE_abcd', 'buffer is: '||buffer);

        -- samplefunction kompilieren
        function_result := create_function(REPLACE(UPPER(mod_sample_function),'FUNCTION ','FUNCTION '||UPPER(identifier_key)||'_SAMPLE_'),message);
        -- return on error (should never happen)
        IF function_result = -1 THEN
            OPEN evaluation_result FOR
                Select -3 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
            RETURN evaluation_result;
        END IF;




        -- hier müssten firingstatements auf beide funktion losgelassen werden
-- example in firingstatements steht:
        --- eur_to_usd(15);
        -- dann wird daraus IDKEY_eur_to_usd(15) und IDKEY_SAMPLE_eur_to_usd(15)

-- get the function calls from the table
--SELECT CALL INTO v_func_call FROM FUNC_CALLS WHERE QUESTIONID = question_id ORDER BY EXECORDER ASC;

        OPEN func_call_cursor;
        LOOP
            FETCH func_call_cursor INTO v_func_call;
            EXIT WHEN func_call_cursor%NOTFOUND;
            v_func_call_user := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_'||UPPER(func_name));
            v_func_call_sample := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_SAMPLE_'||UPPER(func_name));

            -- execute function save result in function_result - save return value in output table
            -- EXECUTE IMMEDIATE v_func_call_user INTO function_result;
            execute immediate 'begin :eval_result := ' ||v_func_call_user|| '; end;' USING OUT eval_result;
            eval_result := v_func_call || ': ' || eval_result;
            sql_stmt := REPLACE('INSERT INTO "OUTPUT_TABLE_XXX" (COLUMN_VALUE) VALUES (:1)','XXX',UPPER(identifier_key));
            EXECUTE IMMEDIATE sql_stmt USING eval_result;

            --EXECUTE IMMEDIATE v_func_call_sample INTO function_result;
            --function_result := AI1325_SAMPLE_EUR_TO_USD(15);
            execute immediate 'begin :eval_result := ' ||v_func_call_sample|| '; end;' USING OUT eval_result;
            eval_result := v_func_call || ': ' || eval_result;
            sql_stmt := REPLACE('INSERT INTO "OUTPUT_TABLE_SAMPLE_XXX" (COLUMN_VALUE) VALUES (:1)','XXX',UPPER(identifier_key));
            EXECUTE IMMEDIATE sql_stmt USING eval_result;
        END LOOP;
        CLOSE func_call_cursor;


        -- ergebnisse vergleichen
-- table_name ist in den meisten fällen (dbms_output) OUTPUT_TABLE

        sql_stmt := UPPER(' select count(*) from(
                    (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_SAMPLE_' || identifier_key || ')
                    UNION ALL
                    (select * from ' || table_name || '_SAMPLE_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || ')
                    )');

        EXECUTE IMMEDIATE sql_stmt INTO result_difference;

        IF result_difference = 0 THEN
            message := 'Die Funktion hat das gewünschte Ergebnis zurückgeliefert!';
            resultnumber := 1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        ELSE
            SELECT get_json_fnc('edb_plsql_func_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
            SELECT get_json_fnc('edb_plsql_func_app.get_table_data(''' || table_name || '_SAMPLE_' || identifier_key || ''')') INTO resultreferencetable FROM DUAL;

            message := 'Die Funktion hat das falsche Ergebnis zurückgeliefert!';
            resultnumber := -1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
        END IF;


        -- Datenbank bereinigen
--  drop table xyz_sample_function_output;
--  drop table xyz_sample_function_output;
        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

--  drop userfunction
        function_result := delete_function(identifier_key||'_'||func_name, message);
--  drop samplefunction
        function_result := delete_function(identifier_key||'_SAMPLE_'||func_name, message);

-- return result
        RETURN evaluation_result;

    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Funktion konnte nicht evaluiert werden! ('||sqlerrm||')');
    END evaluate_question;

    PROCEDURE insert_into_output_table
    ( identifier IN VARCHAR2, text IN VARCHAR2 ) AS
        stmt VARCHAR2(1024);
    BEGIN
        stmt:=REPLACE('INSERT INTO OUTPUT_TABLE (COLUMN_VALUE) VALUES(:1)', 'OUTPUT_TABLE', UPPER('OUTPUT_TABLE_'||identifier));
        EXECUTE IMMEDIATE stmt USING text;
    END insert_into_output_table;

    FUNCTION get_calls
    ( question_id IN NUMBER )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT CALL
            FROM FUNC_CALLS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;

        RETURN select_result;
    END get_calls;

END edb_plsql_func_app;

/
--------------------------------------------------------
--  DDL for Package Body EDB_PLSQL_PROC_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE BODY "EDB_PLSQL_PROC_APP" IS

    FUNCTION create_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        SELECT dbms_metadata.get_ddl('TABLE', table_name) INTO command FROM dual;
        command := REPLACE(REPLACE(REPLACE(REPLACE(command,table_name,table_name||'_'||identifier_key),'CONSTRAINT "','CONSTRAINT "'||identifier_key||'_'),'"',''),';','');
        EXECUTE IMMEDIATE command;
        EXECUTE IMMEDIATE 'INSERT INTO '||table_name||'_'||identifier_key||' SELECT * FROM '||table_name;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle ' ||table_name||'_'||identifier_key|| ' konnte nicht angelegt werden! ('||sqlerrm||')');
    END create_table;

    FUNCTION delete_table
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP TABLE '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        RETURN 1;
    -- raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! ('||sqlerrm||')');
    END delete_table;

    FUNCTION create_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
        command VARCHAR2(2048);
    BEGIN
        command := 'CREATE VIEW ' || table_name || '_' || identifier_key || ' AS SELECT * FROM ' || table_name;
        EXECUTE IMMEDIATE command;
        COMMIT;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die View ' || table_name || '_' || identifier_key || ' konnte nicht angelegt werden! (' || sqlerrm || ')');
    END create_view;

    FUNCTION delete_view
    ( table_name IN varchar2, identifier_key IN varchar2 )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP View '||table_name||'_'||identifier_key;
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! (' || sqlerrm || ')');
    END delete_view;

    FUNCTION get_table_colum_names
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT COLUMN_NAME FROM ALL_TAB_COLUMNS WHERE TABLE_NAME=UPPER(v_table_name);

        RETURN select_result;
    END get_table_colum_names;

    FUNCTION get_table_data
    ( v_table_name IN VARCHAR2 )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
                'SELECT * FROM ' || v_table_name;

        RETURN select_result;
    END get_table_data;

    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB AS
        /*====================================================================================================+
        FUNCTION:   GET_JSON_FNC

        SUMMARY:   TO generate JSON string dynamically from SYS_REFCURSOR

        Revision History:
        Date          Name                             Revision      Description
        ======================================================================================================
         11-AUG-13     Swadhin Ray(Sloba)                   1.0       First Version
        ======================================================================================================*/
        lhtmloutput   xmltype;
        lxsl          LONG;
        lxmldata      xmltype;
        lcontext      dbms_xmlgen.ctxhandle;
        l_ret_clob    CLOB;
        desc_cur      NUMBER;
        l_descr_tab   dbms_sql.desc_tab2;
        l_num_cols    NUMBER;
        l_header_clob CLOB;
        l_row_data    VARCHAR2(100);
        l_ip_rfc      SYS_REFCURSOR;
        l_exec_comm   VARCHAR2(250);
    BEGIN
        l_exec_comm := 'SELECT ' || ip_rfc || ' from dual';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;

        l_header_clob := '{"metadata":[';
        desc_cur      := dbms_sql.to_cursor_number(l_ip_rfc);

        dbms_sql.describe_columns2(desc_cur
            ,l_num_cols
            ,l_descr_tab);

        FOR i IN 1 .. l_num_cols
            LOOP
                CASE
                    WHEN l_descr_tab(i).col_type IN (2
                        ,8) THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"number"},';
                    WHEN l_descr_tab(i).col_type = 12 THEN
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"date"},';
                    ELSE
                        l_row_data := '{"name":"' || l_descr_tab(i)
                            .col_name || '","type":"text"},';
                    END CASE;
                dbms_lob.writeappend(l_header_clob
                    ,length(l_row_data)
                    ,l_row_data);
            END LOOP;
        l_header_clob := rtrim(l_header_clob
                             ,',') || '],"data":';

        EXECUTE IMMEDIATE l_exec_comm
            INTO l_ip_rfc;
        lcontext := dbms_xmlgen.newcontext(l_ip_rfc);
        dbms_xmlgen.setnullhandling(lcontext
            ,1);
        lxmldata := dbms_xmlgen.getxmltype(lcontext
            ,dbms_xmlgen.none);
        -- this is a XSL for JSON
        lxsl := '<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html"/>
<xsl:template match="/">[<xsl:for-each select="/ROWSET/*">
  {<xsl:for-each select="./*">
    "<xsl:value-of select="name()"/>":"<xsl:value-of select="text()"/>"<xsl:choose>
      <xsl:when test="position()!= last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
  }<xsl:choose>
      <xsl:when test="position() != last()">,</xsl:when>
    </xsl:choose>
   </xsl:for-each>
]}</xsl:template></xsl:stylesheet>';

        lhtmloutput := lxmldata.transform(xmltype(lxsl));
        l_ret_clob  := lhtmloutput.getclobval();
        l_ret_clob  := REPLACE(l_ret_clob
            ,'_x0020_'
            ,' ');
        dbms_lob.writeappend(l_header_clob
            ,length(l_ret_clob)
            ,l_ret_clob);
        RETURN l_header_clob;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            dbms_output.put_line(dbms_utility.format_error_backtrace);
            RETURN NULL;
    END get_json_fnc;

    FUNCTION get_questions
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    PROCNAME ,
                    SAMPLEPROC  FROM PROC_QUESTIONS ORDER BY QUESTIONID ASC;

        RETURN select_result;
    END get_questions;

    FUNCTION get_question
    ( question_id IN NUMBER)
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT  QUESTIONID ,
                    QUESTIONTYP ,
                    NEEDEDTABLE ,
                    TEXT ,
                    TESTTABLE ,
                    PROCNAME ,
                    SAMPLEPROC  FROM PROC_QUESTIONS WHERE QUESTIONID = question_id;

        RETURN select_result;
    END get_question;

    FUNCTION create_procedure
    ( function IN VARCHAR2, msg OUT VARCHAR )
        RETURN NUMBER AS
        error VARCHAR2(4000 BYTE);
        proc VARCHAR2(1024);
        stmt VARCHAR2(1024);
    BEGIN
        proc := REGEXP_SUBSTR(function, 'PROCEDURE\s*(\w*)', 1, 1, NULL, 1);
        EXECUTE IMMEDIATE function;
        msg:= 'Erfolgreich: Die Prozedur wurde ohne Fehler kompiliert!';
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        stmt := 'SELECT ''Zeile '' || line || '', Spalte '' || position || '' - '' || text FROM USER_ERRORS WHERE NAME = :funcname FETCH FIRST 1 ROWS ONLY';
        EXECUTE IMMEDIATE stmt INTO error USING proc;
        msg := 'Fehler: Die Funktion konnte nicht kompiliert werden! (' || sqlerrm || ') - Details: ' || error || ')';
        EXECUTE IMMEDIATE 'DROP PROCEDURE ' || proc;
        RETURN -1;
    END create_procedure;

    FUNCTION delete_procedure
    ( function_name IN VARCHAR2, msg OUT VARCHAR )
        RETURN NUMBER AS
    BEGIN
        EXECUTE IMMEDIATE 'DROP PROCEDURE '||function_name;
        msg:= 'Erfolgreich: Die Prozedur wurde ohne Fehler gelöscht!';
        RETURN 1;
    EXCEPTION WHEN OTHERS THEN
        msg := 'Fehler: Die Prozedur konnte nicht gelöscht werden! (' || sqlerrm || ')';
        RETURN -1;
    END delete_procedure;

    FUNCTION evaluate_question
    ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2)
        RETURN sys_refcursor AS
        evaluation_result sys_refcursor;
        user_result VARCHAR(4000 BYTE);
        mod_user_function VARCHAR(1024);
        sample_function VARCHAR(1024);
        mod_sample_function VARCHAR(1024);
        table_name VARCHAR(128);
        func_name VARCHAR(128);
        l_needed_table VARCHAR(128);
        l_tablen  BINARY_INTEGER;
        l_tab DBMS_UTILITY.uncl_array;
        function_result NUMBER;
        eval_result VARCHAR2(1024);
        message VARCHAR2(10000 BYTE);
        v_object_type VARCHAR2(32);
        v_func_call VARCHAR2(500);
        v_func_call_user VARCHAR2(500);
        v_func_call_sample VARCHAR2(500);
        result_difference NUMBER;
        resultnumber NUMBER;
        resulttesttable CLOB;
        resultreferencetable CLOB;
        sql_stmt VARCHAR2(512);
        CURSOR func_call_cursor IS
            SELECT CALL
            FROM PROC_CALLS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;
    BEGIN

        -- select samplefunction (solution) from FUNCTIONQUESTION
        SELECT SAMPLEPROC, UPPER(TESTTABLE), PROCNAME, NEEDEDTABLE INTO sample_function, table_name, func_name, l_needed_table
        FROM PROC_QUESTIONS WHERE QUESTIONID = question_id;

-- mit komma getrennte liste (l_needed_table) wird hier geparst
        DBMS_UTILITY.comma_to_table (
                list   => l_needed_table,
                tablen => l_tablen,
                tab    => l_tab);

        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                END IF;
            END LOOP;

-- erstellen der needed tables (identifier_key wird an tabellennamen angehangen)
        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := create_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := create_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := create_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

-- übergebene userfunktion muss vorbereitet werden -> mod_user_function
        mod_user_function := user_function;

        -- needed_tables mit identifier_key erweitern
        FOR i IN 1 .. l_tablen LOOP
                mod_user_function := REPLACE(UPPER(mod_user_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_'||identifier_key));
            END LOOP;
        --   dbms_output durch eigenen Funktionsaufruf ersetzen
        -- mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_'||identifier_key||' VALUES');
        mod_user_function := REPLACE(UPPER(mod_user_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_proc_app.insert_into_output_table('''||identifier_key||''', ' );
        --     DBMS_OUTPUT.PUT_LINE('buffer is: '||buffer);
        -- insert_into_output_table('abcd', 'buffer is: '||buffer);

        -- userfunction mit identifier_key erweitern und kompilieren
        function_result := create_procedure(REPLACE(UPPER(mod_user_function),'PROCEDURE ','PROCEDURE '||UPPER(identifier_key)||'_'),message);
        -- return on compilation error
        IF function_result = -1 THEN
            OPEN evaluation_result FOR
                Select -2 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
            RETURN evaluation_result;
        END IF;


        -- samplefunction mit identifier_key erweitern
        -- dbms_output durch inserts ersetzen
        mod_sample_function := sample_function;

        FOR i IN 1 .. l_tablen LOOP
                mod_sample_function := REPLACE(UPPER(mod_sample_function),UPPER(l_tab(i)),UPPER(l_tab(i)||'_SAMPLE_'||identifier_key));
            END LOOP;
        -- mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE', 'INSERT INTO OUTPUT_TABLE_SAMPLE_'||identifier_key||' VALUES');
        mod_sample_function := REPLACE(UPPER(mod_sample_function),'DBMS_OUTPUT.PUT_LINE(', 'edb_plsql_proc_app.insert_into_output_table(''SAMPLE_'||identifier_key||''', ' );
        -- insert_into_output_table('SAMPLE_abcd', 'buffer is: '||buffer);

        -- samplefunction kompilieren
        function_result := create_procedure(REPLACE(UPPER(mod_sample_function),'PROCEDURE ','PROCEDURE '||UPPER(identifier_key)||'_SAMPLE_'),message);
        -- return on error (should never happen)
        IF function_result = -1 THEN
            OPEN evaluation_result FOR
                Select -3 AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
            RETURN evaluation_result;
        END IF;




        -- hier müssten firingstatements auf beide funktion losgelassen werden
-- example in firingstatements steht:
        --- eur_to_usd(15);
        -- dann wird daraus IDKEY_eur_to_usd(15) und IDKEY_SAMPLE_eur_to_usd(15)

-- get the function calls from the table
--SELECT CALL INTO v_func_call FROM PROC_CALLS WHERE QUESTIONID = question_id ORDER BY EXECORDER ASC;

        OPEN func_call_cursor;
        LOOP
            FETCH func_call_cursor INTO v_func_call;
            EXIT WHEN func_call_cursor%NOTFOUND;
            v_func_call_user := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_'||UPPER(func_name));
            v_func_call_sample := REPLACE(UPPER(v_func_call),UPPER(func_name),identifier_key||'_SAMPLE_'||UPPER(func_name));

            -- execute function save result in function_result - save return value in output table
            -- EXECUTE IMMEDIATE v_func_call_user INTO function_result;

            execute immediate 'begin ' ||v_func_call_user|| '; end;';

            execute immediate 'begin ' ||v_func_call_sample|| '; end;';



        END LOOP;
        CLOSE func_call_cursor;

        -- ergebnisse vergleichen
-- table_name ist in den meisten fällen (dbms_output) OUTPUT_TABLE

        sql_stmt := UPPER(' select count(*) from(
                    (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_SAMPLE_' || identifier_key || ')
                    UNION ALL
                    (select * from ' || table_name || '_SAMPLE_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || ')
                    )');

        EXECUTE IMMEDIATE sql_stmt INTO result_difference;

        IF result_difference = 0 THEN
            message := 'Die Funktion hat das gewünschte Ergebnis zurückgeliefert!';
            resultnumber := 1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE FROM DUAL;
        ELSE
            SELECT get_json_fnc('edb_plsql_proc_app.get_table_data(''' || table_name || '_' || identifier_key || ''')') INTO resulttesttable FROM DUAL;
            SELECT get_json_fnc('edb_plsql_proc_app.get_table_data(''' || table_name || '_SAMPLE_' || identifier_key || ''')') INTO resultreferencetable FROM DUAL;

            message := 'Die Funktion hat das falsche Ergebnis zurückgeliefert!';
            resultnumber := -1;

            OPEN evaluation_result FOR
                SELECT resultnumber AS RESULTNUMBER, message AS RESULTMESSAGE, REPLACE(resulttesttable,'&quot;','"') AS resulttesttable, REPLACE(resultreferencetable,'&quot;','"') AS resultreferencetable FROM DUAL;
        END IF;


        -- Datenbank bereinigen
--  drop table xyz_sample_function_output;
--  drop table xyz_sample_function_output;
        FOR i IN 1 .. l_tablen LOOP
                SELECT object_type INTO v_object_type FROM all_objects WHERE object_name LIKE UPPER(l_tab(i));
                IF v_object_type = 'TABLE' THEN
                    function_result := delete_table(UPPER(l_tab(i)),UPPER(identifier_key));
                    function_result := delete_table(UPPER(l_tab(i)),'SAMPLE_'||UPPER(identifier_key));
                ELSIF v_object_type = 'VIEW' THEN
                    function_result := delete_view(UPPER(l_tab(i)),UPPER(identifier_key));
                END IF;
            END LOOP;

--  drop userfunction
        function_result := delete_procedure(identifier_key||'_'||func_name, message);
--  drop samplefunction
        function_result := delete_procedure(identifier_key||'_SAMPLE_'||func_name, message);

-- return result
        RETURN evaluation_result;

    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20101, 'Fehler: Die Funktion konnte nicht evaluiert werden! ('||sqlerrm||')');
    END evaluate_question;

    PROCEDURE insert_into_output_table
    ( identifier IN VARCHAR2, text IN VARCHAR2 ) AS
        stmt VARCHAR2(1024);
    BEGIN
        stmt:=REPLACE('INSERT INTO OUTPUT_TABLE (COLUMN_VALUE) VALUES(:1)', 'OUTPUT_TABLE', UPPER('OUTPUT_TABLE_'||identifier));
        EXECUTE IMMEDIATE stmt USING text;
    EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20108, 'Fehler: Konnte nicht in output_table schreiben! ('||sqlerrm||')');
    END insert_into_output_table;

    FUNCTION get_calls
    ( question_id IN NUMBER )
        RETURN  sys_refcursor AS
        select_result sys_refcursor;
    BEGIN
        OPEN select_result FOR
            SELECT CALL
            FROM PROC_CALLS
            WHERE QUESTIONID = question_id
            ORDER BY EXECORDER ASC;

        RETURN select_result;
    END get_calls;

END edb_plsql_proc_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE "EDB_PLSQL_APP" AUTHID CURRENT_USER IS
    FUNCTION evaluate_question ( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
    FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_table_if_exists ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION create_trigger( trigger IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
    FUNCTION fire_trigger ( question_id IN NUMBER, l_needed_table IN varchar2, identifier_key IN VARCHAR2 ) RETURN NUMBER;
    FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
    FUNCTION get_questions RETURN sys_refcursor;
    FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_firing_statements ( question_id IN NUMBER ) RETURN  sys_refcursor;
    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
END edb_plsql_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_FUNC_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE "EDB_PLSQL_FUNC_APP" AUTHID CURRENT_USER IS
    FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
    FUNCTION get_questions RETURN  sys_refcursor;
    FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
    FUNCTION create_function ( function IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
    FUNCTION evaluate_question ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
    FUNCTION delete_function ( function_name IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
    PROCEDURE insert_into_output_table ( identifier IN VARCHAR2, text IN VARCHAR2 );
    FUNCTION get_calls ( question_id IN NUMBER ) RETURN  sys_refcursor;
END edb_plsql_func_app;

/
--------------------------------------------------------
--  DDL for Package EDB_PLSQL_PROC_APP
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE PACKAGE "EDB_PLSQL_PROC_APP" AUTHID CURRENT_USER IS
    FUNCTION create_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_table ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION create_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION delete_view ( table_name IN varchar2, identifier_key IN varchar2 ) RETURN NUMBER;
    FUNCTION get_table_colum_names ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_table_data ( v_table_name IN VARCHAR2 ) RETURN sys_refcursor;
    FUNCTION get_json_fnc(ip_rfc VARCHAR2) RETURN CLOB;
    FUNCTION get_questions RETURN  sys_refcursor;
    FUNCTION get_question ( question_id IN NUMBER) RETURN  sys_refcursor;
    FUNCTION create_procedure ( function IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
    FUNCTION evaluate_question ( question_id IN NUMBER, user_function IN VARCHAR2, identifier_key IN VARCHAR2) RETURN sys_refcursor;
    FUNCTION delete_procedure ( function_name IN VARCHAR2, msg OUT VARCHAR ) RETURN NUMBER;
    PROCEDURE insert_into_output_table ( identifier IN VARCHAR2, text IN VARCHAR2 );
    FUNCTION get_calls ( question_id IN NUMBER ) RETURN  sys_refcursor;
END edb_plsql_proc_app;

/
--------------------------------------------------------
--  DDL for Function CHECK_TRIGGER
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "CHECK_TRIGGER"
( question_id IN NUMBER, message OUT VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
        SELECT FIRINGCODE
        FROM FIRINGSTATEMENTS
        WHERE QUESTIONID = question_id;
BEGIN
    OPEN test_statement_cursor;
    LOOP
        FETCH test_statement_cursor INTO test_statement;
        EXIT WHEN test_statement_cursor%NOTFOUND;
        EXECUTE IMMEDIATE test_statement;
    END LOOP;
    CLOSE test_statement_cursor;
    message := 'Erfolgreich: Der Trigger wurde ohne Fehler ausgeführt';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    message := 'Fehler: Bei der Ausführung des Triggers ist ein Fehler aufgetreten! ('||sqlerrm||')';
    RETURN -1;
END;

/
--------------------------------------------------------
--  DDL for Function CREATE_DDL
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "CREATE_DDL" (eingabe IN varchar2, loesung IN varchar2, eingabe_drop in VARCHAR2, loesung_drop in VARCHAR2 )
    RETURN sys_refcursor IS
    c NUMBER;
    code NUMBER;
    message  varchar2(50 char);
    v_result sys_refcursor;

BEGIN
    execute IMMEDIATE eingabe;
    code := SQLCODE;
    message := SQLERRM;

    select count(ora_error_id)INTO c from ora_error where ora_error_id = code;

    IF c = 0 THEN
        INSERT INTO ORA_ERROR (ora_error_id, error_text) VALUES (code, message);
        commit;
    END IF;

    OPEN v_result for
        SELECT * FROM ora_error WHERE ora_error_id = code;

    EXECUTE IMMEDIATE eingabe_drop;

    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        code := SQLCODE;
        message := SQLERRM;
        --EXECUTE IMMEDIATE tabelle;

        select count(ora_error_id)INTO c from ora_error where ora_error_id = code;

        IF c = 0 THEN
            INSERT INTO ORA_ERROR (ora_error_id, error_text) VALUES (code, message);
            COMMIT;
        END IF;

        OPEN v_result FOR
            SELECT * FROM ora_error WHERE ora_error_id = code;

        RETURN v_result;

END create_ddl;






/
--------------------------------------------------------
--  DDL for Function CREATE_TABLE
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "CREATE_TABLE"
( tablename IN varchar2, identifierKey IN varchar2 )
    return NUMBER AUTHID CURRENT_USER AS
    command VARCHAR2(2048);
BEGIN
    SELECT dbms_metadata.get_ddl('TABLE', tablename) INTO command FROM dual;
    command := REPLACE(REPLACE(REPLACE(REPLACE(command,tablename,tablename||'_'||identifierKey),'CONSTRAINT "','CONSTRAINT "'||identifierKey||'_'),'"',''),';','');
    EXECUTE IMMEDIATE command;
    EXECUTE IMMEDIATE 'INSERT INTO '||tablename||'_'||identifierKey||' SELECT * FROM '||tablename;
    COMMIT;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht angelegt werden! ('||sqlerrm||')');
END;

/
--------------------------------------------------------
--  DDL for Function CREATE_TRIGGER
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "CREATE_TRIGGER"
( trigger IN VARCHAR2, msg OUT VARCHAR )
    RETURN INT  AUTHID CURRENT_USER AS
BEGIN
    EXECUTE IMMEDIATE trigger;

    msg:= 'Erfolgreich: Der Trigger wurde ohne Fehler kompiliert!';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    msg := 'Fehler: ' || sqlerrm;
    RETURN -1;
END;

/
--------------------------------------------------------
--  DDL for Function DELETE_TABLE
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "DELETE_TABLE"
( tablename IN varchar2, identifierKey IN varchar2)
    RETURN NUMBER AUTHID CURRENT_USER as
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE '||tablename||'_'||identifierKey;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    raise_application_error(-20101, 'Fehler: Die Tabelle konnte nicht gelöscht werden! ('||sqlerrm||')');
END;

/
--------------------------------------------------------
--  DDL for Function FIRE_TRIGGER
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "FIRE_TRIGGER"
( question_id IN NUMBER, table_name IN varchar2, identifier_key IN VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
        SELECT FIRINGCODE
        FROM FIRINGSTATEMENTS
        WHERE QUESTIONID = question_id
        ORDER BY EXECORDER ASC;
BEGIN
    OPEN test_statement_cursor;
    LOOP
        FETCH test_statement_cursor INTO test_statement;
        EXIT WHEN test_statement_cursor%NOTFOUND;
        EXECUTE IMMEDIATE REPLACE(UPPER(test_statement),UPPER(table_name),UPPER(table_name || '_' || identifier_key));
    END LOOP;
    CLOSE test_statement_cursor;
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    RETURN 1;
END;

/
--------------------------------------------------------
--  DDL for Function GET_QUESTION
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "GET_QUESTION"
( question_id IN NUMBER)
    RETURN  sys_refcursor AS
    select_result sys_refcursor;
BEGIN
    OPEN select_result FOR
        SELECT  QUESTIONID ,
                TEXT ,
                TESTTABLE ,
                TRIGGERNAME ,
                SAMPLETRIGGER  FROM QUESTIONS WHERE QUESTIONID = question_id;

    RETURN select_result;
END;

/
--------------------------------------------------------
--  DDL for Function PROOF_QUESTION
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "PROOF_QUESTION"
( question_id IN NUMBER, test_trigger IN VARCHAR2, identifier_key IN VARCHAR2, message OUT VARCHAR2)
    RETURN INT AUTHID CURRENT_USER AS
    sample_trigger VARCHAR(1024);
    table_name VARCHAR(128);
    function_result NUMBER;
    result_diffrence NUMBER;
BEGIN
    SELECT SAMPLETRIGGER, UPPER(TESTTABLE) INTO sample_trigger, table_name FROM QUESTIONS WHERE QUESTIONID = question_id;

    function_result := create_table(table_name,identifier_key);

    function_result := create_trigger(REPLACE(REPLACE(UPPER(test_trigger),UPPER(table_name),UPPER(table_name||'_'||identifier_key)),'TRIGGER ','TRIGGER '||identifier_key|| '_'),message);
    IF function_result = -1 THEN
        function_result := delete_table(table_name,identifier_key);
        RETURN -1;
    END IF;

    function_result := fire_trigger(question_id,table_name,identifier_key);

    ---------------------------------------------------------------------
    function_result := create_table(table_name,identifier_key || '_res');

    function_result := create_trigger(REPLACE(REPLACE(UPPER(sample_trigger),UPPER(table_name),UPPER(table_name||'_'||identifier_key|| '_res')),'TRIGGER ','TRIGGER '||identifier_key|| '_res_'),message);
    IF function_result = -1 THEN
        function_result := delete_table(table_name,identifier_key || '_res');
        RETURN -1;
    END IF;

    function_result := fire_trigger(question_id,table_name,identifier_key || '_res');

    -----------------------------------------

    EXECUTE IMMEDIATE ' select count(*) from(
                        (select * from ' || table_name || '_' || identifier_key || ' MINUS select * from ' || table_name || '_' || identifier_key || '_res)
                        UNION ALL
                        (select * from ' || table_name || '_' || identifier_key || '_res MINUS select * from ' || table_name || '_' || identifier_key || '))' INTO result_diffrence;

    function_result := delete_table(table_name,identifier_key);
    function_result := delete_table(table_name,identifier_key || '_res');

    IF result_diffrence = 0 THEN
        message := 'Einwandfrei';
        RETURN 1;
    ELSE
        message := 'Fehler';
        RETURN 1;
    END IF;
END;

/
--------------------------------------------------------
--  DDL for Function TEST_TRIGGER
--------------------------------------------------------

CREATE OR REPLACE EDITIONABLE FUNCTION "TEST_TRIGGER"
( question_id IN NUMBER, message OUT VARCHAR2 )
    RETURN NUMBER AUTHID CURRENT_USER AS
    test_statement VARCHAR2(1024);
    CURSOR test_statement_cursor IS
        SELECT FIRINGCODE
        FROM FIRINGSTATEMENTS
        WHERE QUESTIONID = question_id;
BEGIN
    OPEN test_statement_cursor;
    LOOP
        FETCH test_statement_cursor INTO test_statement;
        EXIT WHEN test_statement_cursor%NOTFOUND;
        EXECUTE IMMEDIATE test_statement;
    END LOOP;
    CLOSE test_statement_cursor;
    message := 'Erfolgreich: Der Trigger wurde ohne Fehler ausgeführt';
    RETURN 1;
EXCEPTION WHEN OTHERS THEN
    message := 'Fehler: Bei der Ausführung des Triggers ist ein Fehler aufgetreten! ('||sqlerrm||')';
    RETURN -1;
END;

/
--------------------------------------------------------
--  Constraints for Table ABTEILUNGEN
--------------------------------------------------------

ALTER TABLE "ABTEILUNGEN" MODIFY ("ABT_NR" NOT NULL ENABLE);
ALTER TABLE "ABTEILUNGEN" MODIFY ("LEITER" NOT NULL ENABLE);
ALTER TABLE "ABTEILUNGEN" MODIFY ("NAME" NOT NULL ENABLE);
ALTER TABLE "ABTEILUNGEN" ADD CONSTRAINT "ABT_PK" PRIMARY KEY ("ABT_NR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ARTIKEL
--------------------------------------------------------

ALTER TABLE "ARTIKEL" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "ARTIKEL" MODIFY ("BEZEICHNUNG" NOT NULL ENABLE);
ALTER TABLE "ARTIKEL" MODIFY ("ARTIKEL_TYP" NOT NULL ENABLE);
ALTER TABLE "ARTIKEL" ADD CONSTRAINT "AR_PK" PRIMARY KEY ("TNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table KUNDEN
--------------------------------------------------------

ALTER TABLE "KUNDEN" MODIFY ("KUN_NR" NOT NULL ENABLE);
ALTER TABLE "KUNDEN" MODIFY ("NACHNAME" NOT NULL ENABLE);
ALTER TABLE "KUNDEN" MODIFY ("VORNAME" NOT NULL ENABLE);
ALTER TABLE "KUNDEN" ADD CONSTRAINT "KUN_PK" PRIMARY KEY ("KUN_NR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORA_ERROR
--------------------------------------------------------

ALTER TABLE "ORA_ERROR" ADD PRIMARY KEY ("ORA_ERROR_ID")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FUNC_CALLS
--------------------------------------------------------

ALTER TABLE "FUNC_CALLS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "FUNC_CALLS" MODIFY ("EXECORDER" NOT NULL ENABLE);
ALTER TABLE "FUNC_CALLS" MODIFY ("CALL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table LIEFERPROGRAMME
--------------------------------------------------------

ALTER TABLE "LIEFERPROGRAMME" MODIFY ("LIEF_NR" NOT NULL ENABLE);
ALTER TABLE "LIEFERPROGRAMME" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "LIEFERPROGRAMME" ADD CONSTRAINT "LP_PK" PRIMARY KEY ("LIEF_NR", "TNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FUNC_QUESTIONS
--------------------------------------------------------

ALTER TABLE "FUNC_QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "FUNC_QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
ALTER TABLE "FUNC_QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
ALTER TABLE "FUNC_QUESTIONS" MODIFY ("FUNCTIONNAME" NOT NULL ENABLE);
ALTER TABLE "FUNC_QUESTIONS" MODIFY ("SAMPLEFUNCTION" NOT NULL ENABLE);
ALTER TABLE "FUNC_QUESTIONS" ADD CONSTRAINT "FUNC_QUESTIONS_PK" PRIMARY KEY ("QUESTIONID")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table GEHALTSPROTOKOLL
--------------------------------------------------------

ALTER TABLE "GEHALTSPROTOKOLL" MODIFY ("ANG_NR" NOT NULL ENABLE);
ALTER TABLE "GEHALTSPROTOKOLL" MODIFY ("DATUM" NOT NULL ENABLE);
ALTER TABLE "GEHALTSPROTOKOLL" ADD CONSTRAINT "GE_PRO_PK" PRIMARY KEY ("ANG_NR", "DATUM")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LIEFERUNGEN
--------------------------------------------------------

ALTER TABLE "LIEFERUNGEN" MODIFY ("LIEFER_NR" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" MODIFY ("LIEF_NR" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" MODIFY ("LIEF_DATUM" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" MODIFY ("MENGE" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" MODIFY ("ZEITSTEMPEL" NOT NULL ENABLE);
ALTER TABLE "LIEFERUNGEN" ADD CONSTRAINT "LG_PK" PRIMARY KEY ("LIEFER_NR", "LIEF_NR", "TNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FIRINGSTATEMENTS
--------------------------------------------------------

ALTER TABLE "FIRINGSTATEMENTS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "FIRINGSTATEMENTS" MODIFY ("EXECORDER" NOT NULL ENABLE);
ALTER TABLE "FIRINGSTATEMENTS" MODIFY ("FIRINGCODE" NOT NULL ENABLE);
ALTER TABLE "FIRINGSTATEMENTS" ADD CONSTRAINT "FIRINGSTATEMENTS_PK" PRIMARY KEY ("QUESTIONID", "EXECORDER")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LAGERBESTAND
--------------------------------------------------------

ALTER TABLE "LAGERBESTAND" MODIFY ("LANR" NOT NULL ENABLE);
ALTER TABLE "LAGERBESTAND" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "LAGERBESTAND" ADD CONSTRAINT "LAG_T_PK" PRIMARY KEY ("LANR", "TNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table QUESTIONS
--------------------------------------------------------

ALTER TABLE "QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
ALTER TABLE "QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
ALTER TABLE "QUESTIONS" MODIFY ("TRIGGERNAME" NOT NULL ENABLE);
ALTER TABLE "QUESTIONS" MODIFY ("SAMPLETRIGGER" NOT NULL ENABLE);
ALTER TABLE "QUESTIONS" ADD CONSTRAINT "QUESTIONS_PK" PRIMARY KEY ("QUESTIONID")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LAGER
--------------------------------------------------------

ALTER TABLE "LAGER" MODIFY ("LANR" NOT NULL ENABLE);
ALTER TABLE "LAGER" MODIFY ("BEZEICHNUNG" NOT NULL ENABLE);
ALTER TABLE "LAGER" ADD CONSTRAINT "LAG_PK" PRIMARY KEY ("LANR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ANGESTELLTE
--------------------------------------------------------

ALTER TABLE "ANGESTELLTE" MODIFY ("ANG_NR" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("ABT_NR" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("AUFGABENBESCHREIBUNG" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("BERUF" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("NACHNAME" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("VORNAME" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" MODIFY ("GESCHLECHT" NOT NULL ENABLE);
ALTER TABLE "ANGESTELLTE" ADD CONSTRAINT "ANG_PK" PRIMARY KEY ("ANG_NR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
ALTER TABLE "ANGESTELLTE" ADD CONSTRAINT "GESCHLECHTX" CHECK ( Geschlecht IN ('w','W','m','M')) ENABLE;
--------------------------------------------------------
--  Constraints for Table TEILE
--------------------------------------------------------

ALTER TABLE "TEILE" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "TEILE" ADD CONSTRAINT "TE_PK" PRIMARY KEY ("TNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
ALTER TABLE "TEILE" ADD CONSTRAINT "TYPX" CHECK ( Typ IN ('Artikel', 'Baugruppe', 'Material')) ENABLE;
--------------------------------------------------------
--  Constraints for Table WERKE
--------------------------------------------------------

ALTER TABLE "WERKE" MODIFY ("WNR" NOT NULL ENABLE);
ALTER TABLE "WERKE" MODIFY ("ORT" NOT NULL ENABLE);
ALTER TABLE "WERKE" MODIFY ("STRASSE" NOT NULL ENABLE);
ALTER TABLE "WERKE" ADD CONSTRAINT "WE_PK" PRIMARY KEY ("WNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUFTRAEGE
--------------------------------------------------------

ALTER TABLE "AUFTRAEGE" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
ALTER TABLE "AUFTRAEGE" MODIFY ("AUFTRAGS_TYP" NOT NULL ENABLE);
ALTER TABLE "AUFTRAEGE" MODIFY ("KUN_NR" NOT NULL ENABLE);
ALTER TABLE "AUFTRAEGE" MODIFY ("ZEITSTEMPEL" NOT NULL ENABLE);
ALTER TABLE "AUFTRAEGE" ADD CONSTRAINT "AU_PK" PRIMARY KEY ("AUFTRAGSNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
ALTER TABLE "AUFTRAEGE" ADD CONSTRAINT "AUFTRAGS_TYPX" CHECK (Auftrags_Typ IN ('Angebot', 'Anfrage', 'Auftrag')) ENABLE;
ALTER TABLE "AUFTRAEGE" ADD CONSTRAINT "DATUMX" CHECK (Bestelldatum <= Lieferdatum) ENABLE;
--------------------------------------------------------
--  Constraints for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

ALTER TABLE "AUFTRAGSPOSITIONEN" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "AUFTRAGSPOSITIONEN" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
ALTER TABLE "AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_PK" PRIMARY KEY ("TNR", "AUFTRAGSNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORTE
--------------------------------------------------------

ALTER TABLE "ORTE" MODIFY ("ORT" NOT NULL ENABLE);
ALTER TABLE "ORTE" MODIFY ("STRASSE" NOT NULL ENABLE);
ALTER TABLE "ORTE" ADD CONSTRAINT "O_PK" PRIMARY KEY ("ORT", "STRASSE")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table STRUKTUR
--------------------------------------------------------

ALTER TABLE "STRUKTUR" MODIFY ("OTEIL" NOT NULL ENABLE);
ALTER TABLE "STRUKTUR" MODIFY ("UTEIL" NOT NULL ENABLE);
ALTER TABLE "STRUKTUR" MODIFY ("POSITION" NOT NULL ENABLE);
ALTER TABLE "STRUKTUR" MODIFY ("MENGE" NOT NULL ENABLE);
ALTER TABLE "STRUKTUR" ADD CONSTRAINT "S_PK" PRIMARY KEY ("OTEIL", "UTEIL", "POSITION")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table GEH_KLASSEN
--------------------------------------------------------

ALTER TABLE "GEH_KLASSEN" MODIFY ("GEH_KLASSE" NOT NULL ENABLE);
ALTER TABLE "GEH_KLASSEN" MODIFY ("MAX_GEHALT" NOT NULL ENABLE);
ALTER TABLE "GEH_KLASSEN" MODIFY ("MIN_GEHALT" NOT NULL ENABLE);
ALTER TABLE "GEH_KLASSEN" ADD CONSTRAINT "G_PK" PRIMARY KEY ("GEH_KLASSE")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table POSITIONSARCHIV
--------------------------------------------------------

ALTER TABLE "POSITIONSARCHIV" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "POSITIONSARCHIV" MODIFY ("AUFTRAGSNR" NOT NULL ENABLE);
ALTER TABLE "POSITIONSARCHIV" ADD CONSTRAINT "PA_PK" PRIMARY KEY ("TNR", "AUFTRAGSNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table PROC_QUESTIONS
--------------------------------------------------------

ALTER TABLE "PROC_QUESTIONS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "PROC_QUESTIONS" MODIFY ("TEXT" NOT NULL ENABLE);
ALTER TABLE "PROC_QUESTIONS" MODIFY ("TESTTABLE" NOT NULL ENABLE);
ALTER TABLE "PROC_QUESTIONS" MODIFY ("PROCNAME" NOT NULL ENABLE);
ALTER TABLE "PROC_QUESTIONS" MODIFY ("SAMPLEPROC" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PROC_CALLS
--------------------------------------------------------

ALTER TABLE "PROC_CALLS" MODIFY ("QUESTIONID" NOT NULL ENABLE);
ALTER TABLE "PROC_CALLS" MODIFY ("EXECORDER" NOT NULL ENABLE);
ALTER TABLE "PROC_CALLS" MODIFY ("CALL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TEILE_WERKE
--------------------------------------------------------

ALTER TABLE "TEILE_WERKE" MODIFY ("TNR" NOT NULL ENABLE);
ALTER TABLE "TEILE_WERKE" MODIFY ("WNR" NOT NULL ENABLE);
ALTER TABLE "TEILE_WERKE" ADD CONSTRAINT "T_WE_PK" PRIMARY KEY ("TNR", "WNR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table LIEFERANTEN
--------------------------------------------------------

ALTER TABLE "LIEFERANTEN" MODIFY ("LIEF_NR" NOT NULL ENABLE);
ALTER TABLE "LIEFERANTEN" MODIFY ("NAME" NOT NULL ENABLE);
ALTER TABLE "LIEFERANTEN" MODIFY ("ORT" NOT NULL ENABLE);
ALTER TABLE "LIEFERANTEN" MODIFY ("STRASSE" NOT NULL ENABLE);
ALTER TABLE "LIEFERANTEN" ADD CONSTRAINT "LIEF_PK" PRIMARY KEY ("LIEF_NR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table KUNDEN_LEON
--------------------------------------------------------

ALTER TABLE "KUNDEN_LEON" MODIFY ("KUN_NR" NOT NULL ENABLE);
ALTER TABLE "KUNDEN_LEON" MODIFY ("NACHNAME" NOT NULL ENABLE);
ALTER TABLE "KUNDEN_LEON" MODIFY ("VORNAME" NOT NULL ENABLE);
ALTER TABLE "KUNDEN_LEON" ADD CONSTRAINT "LEON_KUN_PK" PRIMARY KEY ("KUN_NR")
    USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
        STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
        PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
        BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
        TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ANGESTELLTE
--------------------------------------------------------

ALTER TABLE "ANGESTELLTE" ADD CONSTRAINT "ANG_ABT_FK" FOREIGN KEY ("ABT_NR")
    REFERENCES "ABTEILUNGEN" ("ABT_NR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ARTIKEL
--------------------------------------------------------

ALTER TABLE "ARTIKEL" ADD CONSTRAINT "AR_T_FK" FOREIGN KEY ("TNR")
    REFERENCES "TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AUFTRAEGE
--------------------------------------------------------

ALTER TABLE "AUFTRAEGE" ADD CONSTRAINT "AU_KUN_FK" FOREIGN KEY ("KUN_NR")
    REFERENCES "KUNDEN" ("KUN_NR") ENABLE;
ALTER TABLE "AUFTRAEGE" ADD CONSTRAINT "AU_ANG_FK" FOREIGN KEY ("ANG_NR")
    REFERENCES "ANGESTELLTE" ("ANG_NR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AUFTRAGSPOSITIONEN
--------------------------------------------------------

ALTER TABLE "AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_AR_FK" FOREIGN KEY ("TNR")
    REFERENCES "ARTIKEL" ("TNR") ENABLE;
ALTER TABLE "AUFTRAGSPOSITIONEN" ADD CONSTRAINT "AR_AU_AU_FK" FOREIGN KEY ("AUFTRAGSNR")
    REFERENCES "AUFTRAEGE" ("AUFTRAGSNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FIRINGSTATEMENTS
--------------------------------------------------------

ALTER TABLE "FIRINGSTATEMENTS" ADD CONSTRAINT "FISTAT_QUEST" FOREIGN KEY ("QUESTIONID")
    REFERENCES "QUESTIONS" ("QUESTIONID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LAGERBESTAND
--------------------------------------------------------

ALTER TABLE "LAGERBESTAND" ADD CONSTRAINT "LAG_T_LAG_FK" FOREIGN KEY ("LANR")
    REFERENCES "LAGER" ("LANR") ENABLE;
ALTER TABLE "LAGERBESTAND" ADD CONSTRAINT "LAG_T_T_FK" FOREIGN KEY ("TNR")
    REFERENCES "TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LIEFERPROGRAMME
--------------------------------------------------------

ALTER TABLE "LIEFERPROGRAMME" ADD CONSTRAINT "LP_LIEF_FK" FOREIGN KEY ("LIEF_NR")
    REFERENCES "LIEFERANTEN" ("LIEF_NR") ENABLE;
ALTER TABLE "LIEFERPROGRAMME" ADD CONSTRAINT "LP_T_FK" FOREIGN KEY ("TNR")
    REFERENCES "TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table LIEFERUNGEN
--------------------------------------------------------

ALTER TABLE "LIEFERUNGEN" ADD CONSTRAINT "LG_LIEF_FK" FOREIGN KEY ("LIEF_NR")
    REFERENCES "LIEFERANTEN" ("LIEF_NR") ENABLE;
ALTER TABLE "LIEFERUNGEN" ADD CONSTRAINT "LG_T_FK" FOREIGN KEY ("TNR")
    REFERENCES "TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table STRUKTUR
--------------------------------------------------------

ALTER TABLE "STRUKTUR" ADD CONSTRAINT "S_T_FK2" FOREIGN KEY ("UTEIL")
    REFERENCES "TEILE" ("TNR") ENABLE;
ALTER TABLE "STRUKTUR" ADD CONSTRAINT "S_T_FK" FOREIGN KEY ("OTEIL")
    REFERENCES "TEILE" ("TNR") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TEILE_WERKE
--------------------------------------------------------

ALTER TABLE "TEILE_WERKE" ADD CONSTRAINT "T_WE_T_FK" FOREIGN KEY ("TNR")
    REFERENCES "TEILE" ("TNR") ENABLE;
ALTER TABLE "TEILE_WERKE" ADD CONSTRAINT "T_WE_WE_FK" FOREIGN KEY ("WNR")
    REFERENCES "WERKE" ("WNR") ENABLE;
